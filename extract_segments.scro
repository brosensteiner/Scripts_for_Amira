# Amira-Script-Object V3.0

set moduleName [string map {"\.scro" ""} $this]

set theExtractedSurfacesList {};#this will list contains all extracted surfaces

#i dontÂ´t want name clashes with user given names for modules so here are the hopefully cryptic enough generated names for the needed but hidden modules
set surfaceGen1Name XxXYyYZzZSurfaceGen1_${moduleName}
set surfaceGen2Name XxXYyYZzZSurfaceGen2_${moduleName}
set surfaceView1Name XxXYyYZzZSurfaceView1_${moduleName}
set surfaceView2Name XxXYyYZzZSurfaceView2_${moduleName}
set extractSurface1Name XxXYyYZzZextractSurface1_${moduleName}
set extractSurface2Name XxXYyYZzZextractSurface2_${moduleName}

$this proc sayHello {} {
	global moduleName
   echo "\n************ module \"$moduleName\" loaded successfully :) ************\n"
}
$this proc say {something} {
	global moduleName
	echo "$moduleName: $something"
}

#function which creates moduleType and connects it with sourceName module and checks if connection is valid
#moduleName is the name of the module in the pool
#if moduleName module does not exist it also gets created in the pool
#function returns the name string of the newly created module
$this proc createModuleAndConnectIfOkToSource {moduleType moduleName sourceName {conPortIndex 0}} {

	
	
	if {[lsearch -exact [all $moduleType] $moduleName] == -1} {#test if module is already in the pool -1 := not in pool
	
		 	set returnedModule [create $moduleType $moduleName]
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex];#sets the desired connectionPort name, default is 0
		 	if {[$moduleName $theConnectionPort validSource $sourceName] == 1} {
		 		if {[$moduleName $theConnectionPort source] ne $sourceName} {$moduleName $theConnectionPort connect $sourceName};
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
		 } else {
		 	
		 	set returnedModule $moduleName
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex]
		 	if {[$moduleName $theConnectionPort validSource $sourceName] == 1} {
		 		if {[$moduleName $theConnectionPort source] ne $sourceName} {$moduleName $theConnectionPort connect $sourceName};
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
	}
	
	return $returnedModule
	
}

#switches the given module menu port remotely from $this ($this must have a corresponding port!)
$this proc setCorrespondingPort {module menuPort {menuIndex 0}} {

	upvar #0 $module myModule
	
	$this fire
	set thisMenuIndex [$this $menuPort getValue $menuIndex];#get the value from $this menu (e.g. smoothing port)
	
	$myModule fire
	$myModule $menuPort setValue $menuIndex [string map {0 0 1 2 2 3} $thisMenuIndex];#sting map is important here, this is a buglett in Amira 5 which maps wrong numbers in SurfaceGen smoothing menu. Should be 0,1,2 - but it is 0,2,3!!!
	$myModule fire
	
}

$this proc getToggleValuesAndSomethingWithIt {module1 module1Port module2 module2Port {portIndex 0}} {
	global extractSurface1Name surfaceView1Name
	global theExtractedSurfacesList
	
	for {set i 0} {$i < [$module1 $module1Port getNum]} {incr i} {
	
		if {[$module1 $module1Port getValue $i] == 1} {
			
			set theLabelOfModule1Port [$module1 $module1Port getLabel $i]
			
			$module2 $module2Port setValueString $portIndex $theLabelOfModule1Port
			$module2 fire;#essential: all downStreamConnections must be updated!
			$module2 buffer setValue 0;#add to buffer (hit add button)
			$module2 compute
			
			#here happens the extraction of the surfaces:
			$this createModuleAndConnectIfOkToSource HxViewBaseExtract $extractSurface1Name $surfaceView1Name
			$extractSurface1Name action setValue 0
			$extractSurface1Name fire
			
			set newExtractedSurface [[lindex [$extractSurface1Name downStreamConnections] 0 0] setLabel "$theLabelOfModule1Port.surf"]
			lappend theExtractedSurfacesList $newExtractedSurface;#collecting all surfaces in theExtractedSurfacesList list
			$newExtractedSurface master disconnect;#otherwise the newly created surface gets overriden in the next for loop iteration
			$newExtractedSurface recompute
			$newExtractedSurface cleanup
			$newExtractedSurface compute
			$module2 buffer setValue 2;#remove from buffer (hit remove button)
			$module2 compute
			
		}
		
	}
	
	$module2 buffer setValue 1;#only get rid of the last selection in buffer which would otherwise be visible in the viewer
	$module2 compute
	
	foreach i $theExtractedSurfacesList {
		echo "ok geht: $i"
	}
	
}



 
$this proc constructor {} {

	$this sayHello
	
	$this select
	
	#creates Smoothing menu port and formats it
	$this newPortMultiMenu smoothing 3
	$this smoothing setLabel "Smoothing"
	$this smoothing setLabel 0 0 "none"
	$this smoothing setLabel 0 1 "constrained smoothing"
	$this smoothing setLabel 0 2 "unconstrained smoothing"
	
	#creates the Smoothing port sliders and formats it
	$this newPortFloatSlider  SmoothingSliderPort1
	$this SmoothingSliderPort1 setLabel "SmoothingKernelSize Set 1"
	$this SmoothingSliderPort1 setMinMax 1 9
	$this SmoothingSliderPort1 setFormat "%.2g"
	$this SmoothingSliderPort1 setNumColumns 3
	$this SmoothingSliderPort1 setValue 4;#initial value for smoothing slider
	$this SmoothingSliderPort1 setTracking 1
	
	$this newPortFloatSlider  SmoothingSliderPort2
	$this SmoothingSliderPort2 setLabel "SmoothingKernelSize Set 2"
	$this SmoothingSliderPort2 setMinMax 1 9
	$this SmoothingSliderPort2 setFormat "%.2g"
	$this SmoothingSliderPort2 setNumColumns 3
	$this SmoothingSliderPort2 setValue 4;#initial value for smoothing slider
	$this SmoothingSliderPort2 setTracking 1
	
	#creates Action Button port
	$this newPortDoIt action
	$this action setLabel "Action"
	$this action setLabel 0 "Dolt"
	$this action hide;#actually need not be visible, because apply botton does the job

	#creates new port connections that can connect to HxUniformLabelField3 data class:
	$this newPortConnection VolumeSet1PortCon HxUniformLabelField3
	$this VolumeSet1PortCon setLabel "VolumeSet 1"
	$this newPortConnection VolumeSet2PortCon HxUniformLabelField3
	$this VolumeSet2PortCon setLabel "VolumeSet 2"
	
	#creates the "None" and "All" buttons and formats them
	$this newPortButtonList SelectMatVolSet1 2
	$this SelectMatVolSet1 setLabel "Select Mat. Volume Set 1"
	$this SelectMatVolSet1 setLabel 0 "None"
	$this SelectMatVolSet1 setLabel 1 "All"
	
	$this newPortButtonList SelectMatVolSet2 2
	$this SelectMatVolSet2 setLabel "Select Mat. Volume Set 2"
	$this SelectMatVolSet2 setLabel 0 "None"
	$this SelectMatVolSet2 setLabel 1 "All"

	#$this deletePort Data #shit, can not be deleted hmm...
	
	set hideNewModules 0 

}
  
   
$this proc destructor {} {

	set hideNewModules 0
	
}

$this proc savePreparation {datadir savingFlags} {


}
  
  
$this proc compute {} {
	global moduleName surfaceGen1Name surfaceGen2Name
	global surfaceView1Name surfaceView2Name
	global extractSurface1Name extractSurface2Name

	#some status checks for testing in if blocks
	set myVolumeSet1Source [$this VolumeSet1PortCon source]
	set myVolumeSet2Source [$this VolumeSet2PortCon source]
	
	set myButtonNone1WasHit [$this SelectMatVolSet1 wasHit 0]
	set myButtonAll1WasHit [$this SelectMatVolSet1 wasHit 1]
	set myButtonNone2WasHit [$this SelectMatVolSet2 wasHit 0]
	set myButtonAll2WasHit [$this SelectMatVolSet2 wasHit 1]

	if {[$this VolumeSet1PortCon isNew] == 0} {#if $this has no new port connection
		
		if {[$this action getValue] == 0 && $myVolumeSet1Source ne ""} {# start calculation when action button is pressed and $this has a valid source
		
			workArea setProgressInfo "starting calculation"
			workArea setProgressValue 0.4
			
			$surfaceGen1Name fire
			
			$surfaceGen1Name setVar SmoothKernelSize [$this SmoothingSliderPort1 getValue];#SmoothKernelSize is a internal variable which i will allow to set by user in gui
			$this setCorrespondingPort surfaceGen1Name smoothing;#sets the smoothing port for the hidden SurfaceGen module
			$surfaceGen1Name action setValue 0;#calculate the polygon surface
			
			$surfaceGen1Name fire
			
			$this createModuleAndConnectIfOkToSource HxDisplaySurface $surfaceView1Name [lindex [$surfaceGen1Name downStreamConnections] 0 0];#connect a SurfaceView module and show the result in the Viewer
			
			$surfaceView1Name compute
			$surfaceView1Name buffer setValue 2;#make shure buffer is empty (hits botton "clear"), before filling it again with getToggleValuesAndSomethingWithIt procedure
			$surfaceView1Name compute
			$this getToggleValuesAndSomethingWithIt $this MatVolSet1 $surfaceView1Name materials 1;#sets the buffer in SurfaceView to user specified toggles
			
			workArea setProgressValue 1
			workArea setProgressInfo "$moduleName finished"

		}
				
	} else {#initialization of SurfaceGen (connecting, setting variables ...)
	
		workArea setProgressValue 0.0
	
		if {$myVolumeSet1Source eq ""} {#if $this got disconnected
			$this deletePort MatVolSet1
			$this say "no module connected to VolumeSet1PortCon connection port"
		} else {# $this is newly connected
		
			$this deletePort MatVolSet1
			
			set myMaterialsList1  [$myVolumeSet1Source parameters Materials list]
			set myMaterialCount1 [llength $myMaterialsList1]
			
			$this newPortToggleList MatVolSet1 $myMaterialCount1
			$this MatVolSet1 setLabel "Mat. Volume Set 1"
			
			for {set i 0} {$i <= [$this MatVolSet1 getNum]} {incr i} {
				$this MatVolSet1 setLabel $i [lindex $myMaterialsList1 $i]
			}
			
			
			$this createModuleAndConnectIfOkToSource HxGMC $surfaceGen1Name $myVolumeSet1Source
			
			$surfaceGen1Name fire;
			
			$surfaceGen1Name setVar SmoothKernelSize [$this SmoothingSliderPort1 getValue];
			$this setCorrespondingPort surfaceGen1Name smoothing;
			
			$surfaceGen1Name fire;
						
			$this say "Materials in volume set 1: $myMaterialCount1"
						
		}
			
	}

	if {[$this VolumeSet2PortCon isNew] == 0} {
			#nothing should happen here
	} else {
		
		if {$myVolumeSet2Source eq ""} {
			$this deletePort MatVolSet2
			$this say "no module connected to VolumeSet1PortCon connection port"
		} else {
			
			$this deletePort MatVolSet2
				
			set myMaterialsList2  [$myVolumeSet2Source parameters Materials list]
			set myMaterialCount2 [llength $myMaterialsList2]
			
			$this newPortToggleList "MatVolSet2" $myMaterialCount2
			$this MatVolSet2 setLabel "Mat. Volume Set 2"
			
			for {set i 0} {$i <= [$this MatVolSet2 getNum]} {incr i} {
				$this MatVolSet2 setLabel $i [lindex $myMaterialsList2 $i]
			}
			
			$this say "Materials in volume set 2: $myMaterialCount2"
			
		}
			
	}
	
	
	
	if {$myButtonNone1WasHit == 1 && $myVolumeSet1Source ne ""} {
	
		for {set i 0} {$i <= [$this MatVolSet1 getNum]} {incr i} {
			$this MatVolSet1 setValue $i 0
		}
		$this say "Button \"None\" pressed"
		
	}
	if {$myButtonAll1WasHit == 1 && $myVolumeSet1Source ne ""} {
		for {set i 0} {$i <= [$this MatVolSet1 getNum]} {incr i} {
			$this MatVolSet1 setValue $i 1
		}
		$this say "Button \"All\" pressed"
	}
	
	if {$myButtonNone2WasHit == 1 && $myVolumeSet2Source ne ""} {
	
		for {set i 0} {$i <= [$this MatVolSet2 getNum]} {incr i} {
			$this MatVolSet2 setValue $i 0
		}
		$this say "Button \"None\" pressed"
		
	}
	if {$myButtonAll2WasHit == 1 && $myVolumeSet2Source ne ""} {
		for {set i 0} {$i <= [$this MatVolSet2 getNum]} {incr i} {
			$this MatVolSet2 setValue $i 1
		}
		$this say "Button \"All\" pressed"
	}
	
	
}
  
  