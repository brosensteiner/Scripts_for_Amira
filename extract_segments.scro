# Amira-Script-Object V3.0

set moduleName [string map {"\.scro" ""} $this]

$this setVar runCounter 0
set theExtractedSurfacesList {};#this list keeps track of surfaces of the current run
set theCompleteExtractedSurfacesList {};#this list keeps track of all extracted surfaces from all runs

set myMaterialsList1 [list]
set myMaterialsList2 [list]
set userMaterialsList1Selection [list]
set userMaterialsList2Selection [list]
set myMaterialCount1 0
set myMaterialCount2 0
set volumeSet1LabelSource ""
set volumeSet2LabelSource ""

#i dontÂ´t want name clashes with user given names for modules so here are the hopefully cryptic enough generated names for the needed but hidden modules
set surfaceGen1Modul XxXSurfaceGen1_${moduleName}
set surfaceGen2Modul XxXSurfaceGen2_${moduleName}
set surfaceView1Modul XxXSurfaceView1_${moduleName}
set surfaceView2Modul XxXSurfaceView2_${moduleName}
set extractSurface1Modul XxXextractSurface1_${moduleName}
set extractSurface2Modul XxXextractSurface2_${moduleName}

set alignPrincipalAxesModul XxXalignPrincipalAxes_${moduleName}
set arythmeticModul XxXArithmetic_${moduleName}

$this proc sayHello {} {
	global moduleName
   echo "\n************ module \"$moduleName\" loaded successfully :) ************\n"
}
$this proc say {something} {
	global moduleName
	echo "$moduleName: $something"
}

#function which checks on some $this states and saves some typing:
$this proc checkModuleStateAndSetVariables {} {

	global volumeSet1LabelSource volumeSet2LabelSource
	global myMaterialsList1 myMaterialsList2 myMaterialCount1 myMaterialCount2
	
	$this fire
	
	set volumeSet1LabelSource [$this labField1PortCon source]
	set volumeSet2LabelSource [$this labField2PortCon source]
	
	if {$volumeSet1LabelSource ne ""} {
		set myMaterialsList1  [$volumeSet1LabelSource parameters Materials list]
		set myMaterialCount1 [llength $myMaterialsList1]
	}
	if {$volumeSet2LabelSource ne ""} {
		set myMaterialsList2  [$volumeSet2LabelSource parameters Materials list]
		set myMaterialCount2 [llength $myMaterialsList2]
	}
	
}

#function which creates moduleType and connects it with sourceName module and checks if connection is valid
#moduleName is the name of the module in the pool
#if moduleName module does not exist it also gets created in the pool
#function returns the name string of the newly created module
$this proc createModuleAndConnectIfOkToSource {moduleType moduleName sourceName {conPortIndex 0}} {

	
	
	if {[lsearch -exact [all $moduleType] $moduleName] == -1} {#test if module is already in the pool -1 := not in pool
	
		 	set returnedModule [create $moduleType $moduleName]
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex];#sets the desired connectionPort name, default is 0
		 	if {[$moduleName $theConnectionPort validSource $sourceName] == 1} {
		 		if {[$moduleName $theConnectionPort source] ne $sourceName} {$moduleName $theConnectionPort connect $sourceName};
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
		 } else {
		 	
		 	set returnedModule $moduleName
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex]
		 	if {[$moduleName $theConnectionPort validSource $sourceName] == 1} {
		 		if {[$moduleName $theConnectionPort source] ne $sourceName} {$moduleName $theConnectionPort connect $sourceName};
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
	}
	
	return $returnedModule
	
}

#switches the given module port remotely from $this ($this must have a corresponding (i.e. same) port!)
#it works like the amira built in port connect "<modulename 1> <P0 name> connect < modulename 2> [<P1 name>]" exept that it works (e.g. there are some bugs with menu entry numberation in amira modules)
$this proc setCorrespondingPort {module port {portIndex 0}} {

	upvar #0 $module myModule
	
	if {[info exists myModule] == 0} {
		$this say "hm\.\.\. this module does not exist, maybe you deleted it - restart $moduleName"
	}
	
	$this fire;#infinit loop in Amira when here no update of all downstream modules - crashes most of the time Amira
	
	switch -exact [$this $port getTypeId] {
		HxPortMultiMenu {$myModule $port setValueString $portIndex [$this $port getLabel [$this $port getValue $portIndex]]}
		HxPortToggleList {$myModule $port setValue  $portIndex [$this $port getValue $portIndex]}
		default {$this say "could not find a corresponding port"}
	}
	
	$myModule compute

}

$this proc getToggleValuesAndCreateSurfaces {module1 module1Port module2 module2Port {portIndex 0}} {

	global extractSurface1Modul surfaceView1Modul
	global theExtractedSurfacesList theCompleteExtractedSurfacesList
	global alignPrincipalAxesModul arythmeticModul
	
	set theExtractedSurfacesList {}
	
	for {set i 0} {$i < [$module1 $module1Port getNum]} {incr i} {
	
		if {[$module1 $module1Port getValue $i] == 1} {
			
			set theLabelOfModule1Port [$module1 $module1Port getLabel $i]
			
			$module2 $module2Port setValueString $portIndex $theLabelOfModule1Port
			$module2 fire;#essential: all downStreamConnections must be updated!
			$module2 buffer setValue 0;#add to buffer (hit add button)
			$module2 compute
			
			#here happens the extraction of the surfaces:
			$this createModuleAndConnectIfOkToSource HxViewBaseExtract $extractSurface1Modul $surfaceView1Modul
			$extractSurface1Modul action setValue 0
			$extractSurface1Modul fire
			
			set newExtractedSurface [[lindex [$extractSurface1Modul downStreamConnections] 0 0] setLabel "$theLabelOfModule1Port.surf"]
			
			lappend theExtractedSurfacesList $newExtractedSurface
				
			$newExtractedSurface master disconnect;#otherwise the newly created surface gets overriden in the next for loop iteration
			$newExtractedSurface recompute
			$newExtractedSurface cleanup
			$newExtractedSurface fixOrientation;#helps maybe
			#$newExtractedSurface makeOnePatch
			$newExtractedSurface compute
			$module2 buffer setValue 2;#remove from buffer (hit remove button)
			$module2 compute
			
		}
		
	}
	
	if {$theExtractedSurfacesList eq [list]} {#if list is empty echo warning, else process
		$this say "no labels for extraction selected"
		} else {
		
			lset theCompleteExtractedSurfacesList [concat $theCompleteExtractedSurfacesList $theExtractedSurfacesList];#save all generated surfaces in theCompleteExtractedSurfacesList list
			
			$module2 buffer setValue 1;#only get rid of the last selection in buffer which would otherwise be visible in the viewer
			$module2 compute
			
			#in this foreach iteration the surfaces in the theExtractedSurfacesList list will be further processed
			foreach theSurface $theExtractedSurfacesList {
				
				$this createModuleAndConnectIfOkToSource HxAlignPrincipalAxes $alignPrincipalAxesModul $theSurface
				$alignPrincipalAxesModul action setValue 0
				$alignPrincipalAxesModul fire
				
			}
		
		}
	
	remove $alignPrincipalAxesModul;#AlignPrincipalAxes module is not needed any more.
		
}
#
#******************** the script loopts ********************
#
$this proc constructor {} {
	global volumeSet1LabelSource volumeSet2LabelSource
	global myMaterialsList1 myMaterialsList2 myMaterialCount1 myMaterialCount2
	#$this setNoSave 1

	$this sayHello
	$this select;#$this should be selected after loading
	
	#creates new port connections that can connect to HxUniformLabelField3 data class:
	$this newPortConnection labField1PortCon HxUniformLabelField3
	$this labField1PortCon setLabel "Label Field 1"
	$this newPortConnection labField2PortCon HxUniformLabelField3
	$this labField2PortCon setLabel "Label Field 2"
	
	#creates options for choosing which result will be produced
	$this newPortToggleList result 4
	$this result setLabel "Result"
	$this result setLabel 0 "overwrite"
	$this result setLabel 1 "polygon surface"
	$this result setLabel 2 "voxel data"
	$this result setLabel 3 "resample z"
	
	$this newPortFilename save
	$this save setLabel "Save result"
	$this save setMode 4
	
	#creates Action Button port
	$this newPortDoIt action
	$this action setLabel "Action"
	$this action setLabel 0 "Dolt"
	$this action hide;#actually need not be visible, because apply botton does the job
	
	#setting of global variables
	$this checkModuleStateAndSetVariables;
	
	#creates gui for material selection toggles:
	$this newPortSeparator materialSeparator1
	$this newPortButtonList SelectMatVolSet1 2
	$this SelectMatVolSet1 setLabel "Select Mat. Volume Set 1"
	$this SelectMatVolSet1 setLabel 0 "None"
	$this SelectMatVolSet1 setLabel 1 "All"
	$this newPortToggleList MatVolSet1 $myMaterialCount1
	$this MatVolSet1 setLabel "Mat. Volume Set 1"
	
	#this loop sets the labels for each toggle in MatVolSet1 port:
	for {set i 0} {$i <= [$this MatVolSet1 getNum]} {incr i} {
		$this MatVolSet1 setLabel $i [lindex $myMaterialsList1 $i]
	}
	
	$this newPortSeparator materialSeparator2
	$this newPortButtonList SelectMatVolSet2 2
	$this SelectMatVolSet2 setLabel "Select Mat. Volume Set 2"
	$this SelectMatVolSet2 setLabel 0 "None"
	$this SelectMatVolSet2 setLabel 1 "All"
	$this newPortToggleList MatVolSet2 $myMaterialCount2
	$this MatVolSet2 setLabel "Mat. Volume Set 2"
	
	#this loop sets the labels for each toggle in MatVolSet2 port:
	for {set i 0} {$i <= [$this MatVolSet2 getNum]} {incr i} {
		$this MatVolSet2 setLabel $i [lindex $myMaterialsList2 $i]
	}
	
	
	if {$volumeSet1LabelSource eq ""} {#if $this labField1PortCon is not connected to label field
		$this materialSeparator1 hide
		$this MatVolSet1 hide
		$this SelectMatVolSet1 hide
	} else {
		$this say "Materials in volume set 1: $myMaterialCount1"
	}
	
	if {$volumeSet2LabelSource eq ""} {#if $this labField2PortCon is not connected to label field
		$this materialSeparator2 hide
		$this MatVolSet2 hide
		$this SelectMatVolSet2 hide
	} else {
		$this say "Materials in volume set 2: $myMaterialCount2"
	}
	
			
	#creates smoothing options:
	$this newPortSeparator smoothingSeparator
	$this newPortMultiMenu smoothing 3
	$this smoothing setLabel "Smoothing"
	$this smoothing setLabel 0 0 "none"
	$this smoothing setLabel 0 1 "constrained smoothing"
	$this smoothing setLabel 0 2 "unconstrained smoothing"
	
	$this newPortFloatSlider  SmoothingSliderPort1
	$this SmoothingSliderPort1 setLabel "SmoothingKernelSize"
	$this SmoothingSliderPort1 setMinMax 1 9
	$this SmoothingSliderPort1 setFormat "%.2g"
	$this SmoothingSliderPort1 setNumColumns 3
	$this SmoothingSliderPort1 setValue 4;#initial value for smoothing slider. My tests have shown this is most of the time a good value
	$this SmoothingSliderPort1 setTracking 1
	
	#recreates the options port from SurfaceGen
	$this newPortToggleList options 2
	$this options setLabel "Options"
	$this options setLabel 0 "add border"
	$this options setLabel 1 "compactify"
	
	#recreates the options port from Arithmetic
	$this newPortSeparator voxelSeparator
	$this newPortButtonList voxelBottons 2
	
	#creates resample z options
	$this newPortSeparator resampleSeparator
	$this newPortButtonList resampleButtons 2
	
	
	if {$volumeSet1LabelSource eq "" && $volumeSet2LabelSource eq ""} {
			$this say "connect a label field to one of the label field ports"
	}
	

	#$this data hide;#shit, can not be deleted hmm...
	
}
  
   
$this proc destructor {} {

	global surfaceGen1Modul surfaceGen2Modul arythmeticModul
	global surfaceView1Modul surfaceView2Modul extractSurface1Modul extractSurface2Modul

	#removes the modules which the script created:
	if {[lsearch [all] $surfaceGen1Modul] != -1} { remove $surfaceGen1Modul }
	if {[lsearch [all] $surfaceGen2Modul] != -1} { remove $surfaceGen2Modul }
	if {[lsearch [all] $surfaceView1Modul] != -1} { remove $surfaceView1Modul }
	if {[lsearch [all] $surfaceView2Modul] != -1} { remove $surfaceView2Modul }
	if {[lsearch [all] $extractSurface1Modul] != -1} { remove $extractSurface1Modul }
	if {[lsearch [all] $extractSurface2Modul] != -1} { remove $extractSurface2Modul }
	if {[lsearch [all] $arythmeticModul] != -1} { remove $arythmeticModul }
	
	set hideNewModules 0
	
}

$this proc compute {} {

	workArea startWorking  "Stop"
	$this testBreak;#for safety...
	
	global moduleName surfaceGen1Modul surfaceGen2Modul
	global surfaceView1Modul surfaceView2Modul
	global extractSurface1Modul extractSurface2Modul
	global theExtractedSurfacesList theCompleteExtractedSurfacesList
	global alignPrincipalAxesModul arythmeticModul
	global userMaterialsList1Selection userMaterialsList2Selection
	global volumeSet1LabelSource volumeSet2LabelSource
	global myMaterialsList1 myMaterialsList2 myMaterialCount1 myMaterialCount2

	#some status checks:
	
	$this checkModuleStateAndSetVariables
	
	set myOverwriteToggleIsChecked [$this result getValue 0]
	set myPolygonSurfaceToggleIsChecked [$this result getValue 1]
	set myVoxelDataToggleIsChecked [$this result getValue 2]
	set myResampleZToggleIsChecked [$this result getValue 3]
	
	set resultSelectionState [$this result getState]
	
	
	#checks the bottons states from "None" and "All" and executes their action:
	set myButtonNone1WasHit [$this SelectMatVolSet1 wasHit 0]
	set myButtonAll1WasHit [$this SelectMatVolSet1 wasHit 1]
	set myButtonNone2WasHit [$this SelectMatVolSet2 wasHit 0]
	set myButtonAll2WasHit [$this SelectMatVolSet2 wasHit 1]
	
	#check if buttons are pressed and set toggles
	if {$myButtonNone1WasHit == 1 && $volumeSet1LabelSource ne ""} {
		for {set i 0} {$i <= [$this MatVolSet1 getNum]} {incr i} {
			$this MatVolSet1 setValue $i 0
		}
	}
	if {$myButtonAll1WasHit == 1 && $volumeSet1LabelSource ne ""} {
		for {set i 0} {$i <= [$this MatVolSet1 getNum]} {incr i} {
			$this MatVolSet1 setValue $i 1
		}
	}
	set labelSelection1State [$this MatVolSet1 getState];#state of te selected labels

	if {$myButtonNone2WasHit == 1 && $volumeSet2LabelSource ne ""} {
		for {set i 0} {$i <= [$this MatVolSet2 getNum]} {incr i} {
			$this MatVolSet2 setValue $i 0
		}
	}
	if {$myButtonAll2WasHit == 1 && $volumeSet2LabelSource ne ""} {
		for {set i 0} {$i <= [$this MatVolSet2 getNum]} {incr i} {
			$this MatVolSet2 setValue $i 1
		}
	}
	set labelSelection2State [$this MatVolSet2 getState];#state of te selected labels
	

	#sif connections are new, construct the new gui (toggles with corresponding labels)
	if {[$this labField1PortCon isNew] == 1} {
		
		$this MatVolSet1 setNum $myMaterialCount1
				
		#this loop sets the labels for each toggle in MatVolSet1 port:
		for {set i 0} {$i <= $myMaterialCount1} {incr i} {
			$this MatVolSet1 setLabel $i [lindex $myMaterialsList1 $i]
		}		
		
	} else { $this MatVolSet1 hide }
	if {[$this labField2PortCon isNew] == 1} {

		$this MatVolSet2 setNum $myMaterialCount2
	
		#this loop sets the labels for each toggle in MatVolSet2 port:
		for {set i 0} {$i <= $myMaterialCount2} {incr i} {
			$this MatVolSet2 setLabel $i [lindex $myMaterialsList2 $i]
		}
			
	} else { $this MatVolSet2 hide }
	
	#the following if/elsif statements construct most of the gui when user checks the toggles or connects modules
	if {$volumeSet1LabelSource ne ""} {#if $this labField1PortCon is connected to label field
		$this materialSeparator1 show
		$this MatVolSet1 show
		$this SelectMatVolSet1 show
	} else {
		$this materialSeparator1 hide
		$this MatVolSet1 hide
		$this SelectMatVolSet1 hide
	}
	
	if {$volumeSet2LabelSource ne ""} {#if $this labField2PortCon is connected to label field
		$this materialSeparator2 show
		$this MatVolSet2 show
		$this SelectMatVolSet2 show
	} else {
		$this materialSeparator2 hide
		$this MatVolSet2 hide
		$this SelectMatVolSet2 hide
	}
	
	if {$myPolygonSurfaceToggleIsChecked == 1} {#"polygon surface" is checked
			
		$this smoothingSeparator show
		$this smoothing show
		$this SmoothingSliderPort1 show
		$this options show
				
				
	} else {#"polygon surface" is not checked
	
		$this smoothingSeparator hide
		$this smoothing hide
		$this SmoothingSliderPort1 hide
		$this options hide
		
	}
	if {$myVoxelDataToggleIsChecked == 1} {#"voxel data" is checked
			
		$this voxelSeparator show
		$this voxelBottons show
				
				
	} else {#"voxel data" is not checked
		#TODO: here comes code when "voxel data" is not checked
		$this voxelSeparator hide
		$this voxelBottons hide
		
	}
	if {$myResampleZToggleIsChecked == 1} {#"resample z" is checked
			
		$this resampleSeparator show
		$this resampleButtons show
				
	} else {#"resample z" is not checked
		#TODO: here comes code when "resample z" is not checked
		
		$this resampleSeparator hide
		$this resampleButtons hide
		
	}
	
	
	#first port:
	
	if {[$this action getValue] == 0 && $volumeSet1LabelSource ne ""} {#start calculation when action button is pressed and $this has a valid source
	
		$this setVar runCounter [expr [$this getVar runCounter] + 1];#sets the new runCounter + 1
		$this say "run [$this getVar runCounter]"
		workArea setProgressInfo "starting calculation"
		workArea setProgressValue 0.4
		
		#check which label the user hast selected and save in userMaterialsList1Selection list
		lset userMaterialsList1Selection [list]
		for {set i 0} {$i < [$this MatVolSet1 getNum]} {incr i} {
			if {[$this MatVolSet1 getValue $i] == 1} { lappend userMaterialsList1Selection "[$this MatVolSet1 getLabel $i] $i" }
				
		}
		
		if {$myOverwriteToggleIsChecked == 1 && $theCompleteExtractedSurfacesList ne [list]} {#if toggle is set and list is not empty
		
			foreach i $theCompleteExtractedSurfacesList {
				remove $i
			}
			lset theCompleteExtractedSurfacesList [list];#delete all list elements;#update the theExtractedSurfacesList list -> removes elements
			$this say "old results overwritten"
			
		}
		
		if {$myPolygonSurfaceToggleIsChecked == 1} {
		
			$this createModuleAndConnectIfOkToSource HxGMC $surfaceGen1Modul $volumeSet1LabelSource;
					
			$surfaceGen1Modul fire
		
			$surfaceGen1Modul setVar SmoothKernelSize [$this SmoothingSliderPort1 getValue];#SmoothKernelSize is a internal variable which i will allow to set by user in gui
			
			#sets corresponding gui from $this for the SurfaceGen module:
			$this setCorrespondingPort surfaceGen1Modul options 0;
			$this setCorrespondingPort surfaceGen1Modul options 1;
			$this setCorrespondingPort surfaceGen1Modul smoothing;
							
			$surfaceGen1Modul action setValue 0;#calculate the polygon surface
			
			$surfaceGen1Modul fire
			
			$this createModuleAndConnectIfOkToSource HxDisplaySurface $surfaceView1Modul [lindex [$surfaceGen1Modul downStreamConnections] 0 0];#connect a SurfaceView module for selecting the user specified labels in buffer
		
			$surfaceView1Modul compute
			$surfaceView1Modul buffer setValue 2;#make shure buffer is empty (hits botton "clear"), before filling it again with getToggleValuesAndCreateSurfaces procedure
			$surfaceView1Modul compute
			
			$this getToggleValuesAndCreateSurfaces $this MatVolSet1 $surfaceView1Modul materials 1;#runs main code
			
		}
		
		if {$myVoxelDataToggleIsChecked == 1} {
			
			$this createModuleAndConnectIfOkToSource HxArithmetic $arythmeticModul [$volumeSet1LabelSource ImageData source];#connect a Arithmetic module to the voxelfield which connects to the labelfield
			$arythmeticModul inputB connect $volumeSet1LabelSource
			
			
			for {set i 0} {$i < [llength $userMaterialsList1Selection]} {incr i} {
			
				$this testBreak;#maybe calculation here will take long
				
				$arythmeticModul expr setValue "\(A*\(B==[lindex $userMaterialsList1Selection $i 1]\)\)";#sets the extraction expression
				$arythmeticModul doIt setValue 0;
				$arythmeticModul fire

				set theResultFromArithmeticCalcName [[lindex [$arythmeticModul downStreamConnections] 0 0] setLabel "[lindex $userMaterialsList1Selection $i 0]"];#sets label for newly created voxelfield
				$theResultFromArithmeticCalcName master disconnect;#sisconnect, otherwise the result from arithmetic module will be overridden
					
				lappend theCompleteExtractedSurfacesList $theResultFromArithmeticCalcName;#append extracted voxel field to global theCompleteExtractedSurfacesList
					
			}
						
		}
		
		if {$myResampleZToggleIsChecked == 1} {
			
		}
					
	}

	
	
	
	#second port:

	
	
	#completion of compute procedure:
	if {$volumeSet1LabelSource eq "" && $volumeSet2LabelSource eq "" && [$this getVar runCounter] > 0} {
			$this say "nothing to process - no label field connected"
		}
	if {[lrange $resultSelectionState 3 5] eq [list 0 0 0] && [$this getVar runCounter] > 0} {
			$this say "nothing to process - choose on ore more result options"
		}
		
	workArea setProgressValue 1
	workArea stopWorking
}
  
  