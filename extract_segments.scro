# Amira-Script-Object V3.0

set moduleName [string map {"\.scro" ""} $this];# the name of the module generated from the script filename

# definition of global variables:
$this setVar runCounter 0
$this setVar computeCounter 0

set theExtractedSurfacesList [list];# keeps track of surfaces of the current run
set theArithmeticExtractedSurfacesList [list];# keeps track of all extracted surfaces from arithmetic runs
set theResampleZExtractedSurfacesList [list];# keeps track of all extracted surfaces from resample z runs
set theCompleteExtractedSurfacesList [list];# keeps track of all extracted surfaces from all runs

array set userLabListSelState {};# array for the selection state of user selected toggles 
array set lastLabSetArray {};# array of all labels in last labSet
set labCountList [list];# count list of all lab gui toogles
set allConnectedLabFields [list];# list of all connection ports which have a source
set labSetList [list];# list of all lab sets which are in gui
set userResultSelState [list]
set userSaveState [list]
set emptyConPorts 0;# for counting empty connection ports of $this

# i dont´t want name clashes with user given names for modules
# so here are the hopefully cryptic enough generated names for the modules $this maybe creates
set surfaceGenModul XxXSurfaceGen_${moduleName}
set surfaceViewModul XxXSurfaceView_${moduleName}
set extractSurfaceModul XxXextractSurface1_${moduleName}
set alignPrincipalAxesModul XxXalignPrincipalAxes_${moduleName}
set arythmeticModul XxXArithmetic_${moduleName}

$this proc sayHello {} {
	global moduleName
	echo "\n************ module \"$moduleName\" loaded successfully :) ************\n"
}
$this proc say { something } {
	global moduleName
	echo "$moduleName: $something"
}

# simple port test: procedure returns 1 when modul has port, otherwise it returns 0
$this proc hasPort {modul port} {
	upvar #1 $modul myModule
	if { [lsearch [$myModule allPorts] $port] != -1 } { return 1 } else { return 0 }
}

# function which checks on some $this states, so every time something happens with $this
# it knows it´s actual state and it can be asked about it:
$this proc checkModuleStateAndSetVariables {} {

	global allConnectedLabFields labCountList
	global lastLabSetArray userLabListSelState labSetList emptyConPorts
	
	$this fire
	
	# first make all empty:
	array set userLabListSelState {}
	array set lastLabSetArray {}
	set allConnectedLabFields [list]
	set labCountList [list]
	set labSetList [list]
	set emptyConPorts 0
	
	# and then update again the lists/arrays:
	for { set i 1 } { $i < [llength [$this connectionPorts]] } { incr i } {
	
		if { [$this  [lindex [$this connectionPorts] $i] source] ne "" } {
				
			lappend allConnectedLabFields [$this [lindex [$this connectionPorts] $i] source]
			lappend labCountList [[$this labFieldPortCon$i source] parameters Materials nBundles]
			lappend labSetList labSet$i
			set userLabListSelState($i) [$this labSet$i getState]
			
			for { set x 0 } { $x < [$this labSet$i getNum] } { incr x } {
				set lastLabSetArray([expr $x + 1]) [$this labSet$i getLabel $x]
			}

			# show the ports when connected to label field:
			$this labSeparator$i show
			$this labSetSelBottons$i show
			$this labSet$i show
			
		} else {
			
			set emptyConPorts [incr emptyConPorts];# count every empty connection port
			
			# hide the ports when not connected to label field:
			$this labSeparator$i hide
			$this labSetSelBottons$i hide
			$this labSet$i hide
			
		}
		
	}
	
	# setting the static gui elements:
	set userResultSelState [$this result getState]
	set userSaveState [$this save getState]
	
	# this loop sets the labels for each dynamic toggle in labSet ports:
	for { set x 1 } { $x < [llength [$this connectionPorts]] } { incr x } {
	
		if { [$this labFieldPortCon$x isNew] == 1 && [$this labFieldPortCon$x source] ne ""  } {#set the labels only new when connection port is new - reduces overhead
					
			$this labSet$x setNum [[$this labFieldPortCon$x source] parameters Materials nBundles];# get the number of material from the source and set number of toogles
			for { set y 0 } { $y < [$this labSet$x getNum] } { incr y } {
				$this labSet$x setLabel $y [lindex [[$this labFieldPortCon$x source] parameters Materials list] $y]
			}
			
		}
		
	}
	
	
	# printing $this info (only for debugging):
	$this say "\nuserLabListSelState: [array get userLabListSelState]"
	$this say "lastLabSetArray: [array get lastLabSetArray]"
	$this say "allConnectedLabFields: $allConnectedLabFields"
	$this say "emptyConPorts: $emptyConPorts"
	$this say "labCountList: $labCountList"
	$this say "labSetList: $labSetList"
	$this say "userResultSelState: $userResultSelState"
	$this say "userSaveState: $userSaveState\n"
	
}

# procedure which will be executed when a "None" button is pressed
$this proc bottonNonePressed { num } {
	
	for { set i 0 } { $i <= [$this labSet$num getNum] } { incr i } {
		$this labSet$num setValue $i 0
	}
 	$this checkModuleStateAndSetVariables
 			
}
# procedure which will be executed when a "All" button is pressed
$this proc bottonAllPressed { num } {
 	
	for { set i 0 } { $i <= [$this labSet$num getNum] } { incr i } {
		$this labSet$num setValue $i 1
	}
	$this checkModuleStateAndSetVariables;
  			
}

# procedure creates gui elements (separator, bottons, toggles) for a connected lab field
# argument i is the number of portname
$this proc createConPortButtonsToggles { i } {

	global allConnectedLabFields labCountList
	global lastLabSetArray labSetList
	global userLabListSelState userResultSelState userSaveState emptyConPorts
		
	$this newPortConnection labFieldPortCon$i HxUniformLabelField3
	
	# creates gui for material selection toggles:
	$this newPortSeparator labSeparator$i
	$this newPortButtonList labSetSelBottons$i 2
	$this labSetSelBottons$i setLabel "Selection $i"
	$this labSetSelBottons$i setLabel 0 "None"
	$this labSetSelBottons$i setLabel 1 "All"
	$this newPortToggleList labSet$i 0;# only init, right toggles numbers will be determind when label field is connected
	$this labSet$i setLabel "Label set $i"
	
	# build strings for setCmc commands, because $i has to be evaluated before it is given as argument for setCmd
	# every new botton set will get a individual procedure assigned (which will be executed every time a "None" or "All" botton is pressed),
	# because $i changes with every run of createConPortButtonsToggles procedure
	eval "\$this labSetSelBottons\$i setCmd 0 \{ \$this bottonNonePressed " "$i \}"
	eval "\$this labSetSelBottons\$i setCmd 1 \{ \$this bottonAllPressed " "$i \}"
	
	# ports should initially hidden:
	$this labSeparator$i hide
	$this labSetSelBottons$i hide
	$this labSet$i hide
	
	$this checkModuleStateAndSetVariables;
	
}
# procedure deletes gui elements (separator, bottons, toggles) for a connected lab field
# argument i is the number of portname
$this proc deleteConPortButtonsToggles { i } {

	global allConnectedLabFields labCountList
	global lastLabSetArray labSetList
	global userLabListSelState userResultSelState userSaveState emptyConPorts
		
	$this deletePort labFieldPortCon$i
	$this deletePort labSeparator$i
	$this deletePort labSetSelBottons$i
	$this deletePort labSet$i
	
	$this checkModuleStateAndSetVariables;
	
}

# procedure which will make shure that there is always a free connection port for connecting a label field
# all connection ports at the end will be deleted if there is a free connection port somewhere in the middle
# (is a smarter logic that for example the amira´s own ExtractSurface module has)
$this proc conPortLogic {} {

	global emptyConPorts
	
	# create new connecton port when the last connecton port in the list has connected a label field:
	if { [$this [lindex [$this connectionPorts] end] source] ne "" && $emptyConPorts == 0 } {
		
		$this createConPortButtonsToggles [llength [$this connectionPorts]];
	}
	# delete all connection ports beginning at the end until the first connction port with a connected label field is found:
	for { set i 0 } { $i < [llength [$this connectionPorts]] } { incr i } {
	
		if { [$this [lindex [$this connectionPorts] end] source] eq "" && $emptyConPorts > 1 } {
			$this deleteConPortButtonsToggles [expr [llength [$this connectionPorts]] - 1];
		}
		
	}

}

# procedure which creates moduleType and connects it with sourceName module and checks if connection is valid
# moduleName is the name of the module in the pool
# if moduleName module does not exist it also gets created in the pool
# function returns the name string of the newly created module
$this proc createModuleAndConnectIfOkToSource { moduleType moduleName sourceName { conPortIndex 0 } } {

	
	if { [lsearch [all $moduleType] $moduleName] == -1 } {# test if module is already in the pool -1 := not in pool
	
		 	set returnedModule [create $moduleType $moduleName]
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex];# sets the desired connectionPort name, default is 0
		 	if { [$moduleName $theConnectionPort validSource $sourceName] == 1 } {
		 		if { [$moduleName $theConnectionPort source] ne $sourceName } { $moduleName $theConnectionPort connect $sourceName };
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
		 } else {
		 	
		 	set returnedModule $moduleName
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex]
		 	if { [$moduleName $theConnectionPort validSource $sourceName] == 1 } {
		 		if { [$moduleName $theConnectionPort source] ne $sourceName } { $moduleName $theConnectionPort connect $sourceName };
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
	}
	
	return $returnedModule
	
}

# switches the given module port remotely from $this ($this must have a corresponding (i.e. same) port!)
# it works like the amira built in port connect "<modulename 1> <P0 name> connect < modulename 2> [<P1 name>]" exept, that it works (e.g. there are some bugs with menu entry numeration in amira modules)
$this proc setCorrespondingPort { module port { portIndex 0 } } {

	upvar #0 $module myModule
	
	if { [info exists myModule] == 0 } {
		$this say "hm\.\.\. this module does not exist, maybe you deleted it - restart $moduleName"
	}
	
	$this fire;# infinit loop in Amira when here no update of all downstream modules - crashes most of the time Amira
	
	switch -exact [$this $port getTypeId] {
		HxPortMultiMenu { $myModule $port setValueString $portIndex [$this $port getLabel [$this $port getValue $portIndex]] }
		HxPortToggleList { $myModule $port setValue  $portIndex [$this $port getValue $portIndex] }
		default { $this say "proc setCorrespondingPort: could not find a corresponding port" }
	};# setValueString is more robust than index counting with setValue
	
	$myModule compute

}


#
# ******************** the script loops ********************
#
$this proc constructor {} {

	global allConnectedLabFields labCountList
	global lastLabSetArray labSetList
	global userLabListSelState userResultSelState userSaveState

	# $this setNoSave 1;# $this can now correctly be saved with the network, so no need for this ...

	$this sayHello
	$this select;# $this should be selected after loading
	$this script show;

	# creates options for choosing which result will be produced by $this
	$this newPortToggleList result 4
	$this result setLabel "Result"
	$this result setLabel 0 "overwrite"
	$this result setLabel 1 "polygon surface"
	$this result setLabel 2 "voxel data"
	$this result setLabel 3 "resample z"
	
	$this newPortFilename save
	$this save setLabel "Save result"
	$this save setMode 4
	
	# creates Action Button port
	$this newPortDoIt action
	$this action setLabel "Action"
	$this action setLabel 0 "Dolt"
	$this action hide;# actually need not be visible, because apply botton does the job

	# creates smoothing options:
	$this newPortSeparator smoothingSeparator
	$this newPortMultiMenu smoothing 3
	$this smoothing setLabel "Smoothing"
	$this smoothing setLabel 0 0 "none"
	$this smoothing setLabel 0 1 "constrained smoothing"
	$this smoothing setLabel 0 2 "unconstrained smoothing"
	
	$this newPortFloatSlider  SmoothingSliderPort
	$this SmoothingSliderPort setLabel "SmoothingKernelSize"
	$this SmoothingSliderPort setMinMax 1 9
	$this SmoothingSliderPort setFormat "%.2g"
	$this SmoothingSliderPort setNumColumns 3
	$this SmoothingSliderPort setValue 4;# initial value for smoothing slider. My tests have shown this is most of the time a good value
	$this SmoothingSliderPort setTracking 1
	
	# recreates the options port from SurfaceGen
	$this newPortToggleList options 2
	$this options setLabel "Options"
	$this options setLabel 0 "add border"
	$this options setLabel 1 "compactify"
	
	# recreates the options port from Arithmetic
	$this newPortSeparator voxelSeparator
	$this newPortToggleList voxelOptions 2
	$this voxelOptions setLabel "Extraction options"
	
	# creates resample z options
	$this newPortSeparator resampleSeparator
	$this newPortToggleList resampleOptions 2
	$this resampleOptions setLabel "Resample options"
	
	# when savedLabes is not defined it will with this if statement (will only be the case at first loading $this,
	# afterwards it is always defined -> see proc savePreparation):
	if { ![$this hasVar savedLabels] } {# hasVar is undocumented in Amira ducomentation, but indispensable ...
		 $this setVar savedLabels 1
	}
	# this loop creates the needed dynamic gui elements (savedLabels global variable is the counter for how many will be created):
	for { set i 1 } { $i <= [$this getVar savedLabels] } { incr i } {
		$this createConPortButtonsToggles $i
	}
		
}
  
   
$this proc destructor {} {
	
	global surfaceGenModul arythmeticModul
	global surfaceViewModul extractSurfaceModul
	global userLabListSelState lastLabSetArray allConnectedLabFields labCountList
	global labSetList emptyConPorts

	# removes the modules which the script eventually created when $this gets deleted:
	if { [lsearch [all] $surfaceGenModul] != -1 } { remove $surfaceGenModul }
	if { [lsearch [all] $surfaceViewModul] != -1 } { remove $surfaceViewModul }
	if { [lsearch [all] $extractSurfaceModul] != -1 } { remove $extractSurfaceModul }
	if { [lsearch [all] $arythmeticModul] != -1 } { remove $arythmeticModul }
	
	# unset all global variables:
	unset userLabListSelState
	unset lastLabSetArray
	unset allConnectedLabFields
	unset labCountList
	unset labSetList
	unset emptyConPorts
	
	set hideNewModules 0
	
}

$this proc savePreparation { args } {

	global allConnectedLabFields emptyConPorts
	# saves the gui labes for creating initial gui after loading a network file,
	# when $this is saved with the network file:
	$this say "\nemptyConPorts: $emptyConPorts"
	$this say "\nallConnectedLabFields: $allConnectedLabFields"
	$this setVar savedLabels [expr [llength $allConnectedLabFields] + $emptyConPorts]
	
}

$this proc compute {} {

	$this testBreak;# for safety...
	
	global moduleName surfaceGenModul
	global surfaceViewModul
	global extractSurfaceModul
	global theExtractedSurfacesList theCompleteExtractedSurfacesList theArithmeticExtractedSurfacesList theResampleZExtractedSurfacesList
	global alignPrincipalAxesModul arythmeticModul
	global userLabListSelState

	global allConnectedLabFields labCountList
	global lastLabSetArray labSetList

	# some status checks:
	
	set myOverwriteToggleIsChecked [$this result getValue 0]
	set myPolygonSurfaceToggleIsChecked [$this result getValue 1]
	set myVoxelDataToggleIsChecked [$this result getValue 2]
	set myResampleZToggleIsChecked [$this result getValue 3]
	set resultSelectionState [$this result getState]
	
	$this checkModuleStateAndSetVariables;
	
	if { [$this getVar computeCounter] > 0 } { $this conPortLogic };# procedure conPortLogic will be executed after the first compute run
	
		
	
	# the following if/elsif statements construct most of the gui when user checks the toggles or connects modules
	if { $myPolygonSurfaceToggleIsChecked } {# "polygon surface" is checked
			
		$this smoothingSeparator show
		$this smoothing show
		$this SmoothingSliderPort show
		$this options show
				
				
	} else {# "polygon surface" is not checked
	
		$this smoothingSeparator hide
		$this smoothing hide
		$this SmoothingSliderPort hide
		$this options hide
		
	}
	if { $myVoxelDataToggleIsChecked } {# "voxel data" is checked
			
		$this voxelSeparator show
		$this voxelOptions show
				
				
	} else {# "voxel data" is not checked
		# TODO: here comes code when "voxel data" is not checked
		$this voxelSeparator hide
		$this voxelOptions hide
		
	}
	if { $myResampleZToggleIsChecked } {# "resample z" is checked
			
		$this resampleSeparator show
		$this resampleOptions show
				
	} else {# "resample z" is not checked
		# TODO: here comes code when "resample z" is not checked
		
		$this resampleSeparator hide
		$this resampleOptions hide
		
	}
	
	
	# ********** actions **********
	# enters only here when "Apply" button ($this action port) of $this is pressed:
	
	if { [$this action getValue] == 0 } {# start calculation when action button is pressed and $this has a valid source
	
		workArea startWorking
	
		$this setVar runCounter [expr [$this getVar runCounter] + 1];# sets the new runCounter + 1
		$this say "run [$this getVar runCounter]"
		workArea setProgressInfo "starting calculation"
		workArea setProgressValue 0.4
		
		
		# if toggle "overwrite" is set and list is not empty the next statement deletes all previously by $this generated surfaces:
		if { $myOverwriteToggleIsChecked == 1 && $theCompleteExtractedSurfacesList ne [list] } {
		
			foreach surfaceToRemove $theCompleteExtractedSurfacesList {
				remove $surfaceToRemove
			}
			lset theCompleteExtractedSurfacesList [list];# delete all list elements
			$this say "old results overwritten"
			
		}
		
		# toogle "polygon surface" is checked then the selected labels will be extracted:
		if { $myPolygonSurfaceToggleIsChecked == 1 } {
			
			set labfieldCount 0;# counts only how often the foreach loop has run (is needed for retrieving the correct index from labSetList -> see below)
			
			foreach labelfield $allConnectedLabFields {
			
				$this testBreak
			
				$this createModuleAndConnectIfOkToSource HxGMC $surfaceGenModul $labelfield;# connect to labelfield
				
				$surfaceGenModul fire
				# SmoothKernelSize is a internal, but documented variable which i made visible in the gui, because it is sometimes useful for better quality of polygon surface generation
				$surfaceGenModul setVar SmoothKernelSize [$this SmoothingSliderPort getValue];
				
				# sets corresponding gui from $this for the SurfaceGen module:
				$this setCorrespondingPort surfaceGenModul options 0;
				$this setCorrespondingPort surfaceGenModul options 1;
				$this setCorrespondingPort surfaceGenModul smoothing;
								
				$surfaceGenModul action setValue 0;# calculate the polygon surface
				
				$surfaceGenModul fire
				
				# connect a SurfaceView module for selecting the user specified labels in buffer to the newly generated surface field from surfaceGenModul:
				$this createModuleAndConnectIfOkToSource HxDisplaySurface $surfaceViewModul [lindex [$surfaceGenModul downStreamConnections] 0 0]
						
				$surfaceViewModul compute
				$surfaceViewModul buffer setValue 2;# make shure buffer is empty for the first run (hits botton "clear")
				$surfaceViewModul compute
				
				
				
				set theExtractedSurfacesList [list]
				set theLabSetFromLabSetList [lindex $labSetList $labfieldCount];# the needed labSet port (e.g. labSet1, labSet2 ...)
				
				for { set i 0 } { $i < [$this $theLabSetFromLabSetList getNum] } { incr i } {
				
					if { [$this $theLabSetFromLabSetList getValue $i] == 1 } {
						
						set theLabel [$this $theLabSetFromLabSetList getLabel $i]
						
						$surfaceViewModul materials setValueString $theLabel
						$surfaceViewModul fire;# essential: all downStreamConnections must be updated!
						$surfaceViewModul buffer setValue 0;# add to buffer (hit add button)
						$surfaceViewModul compute
						
						# here happens the extraction of the surfaces:
						$this createModuleAndConnectIfOkToSource HxViewBaseExtract $extractSurfaceModul $surfaceViewModul
						$extractSurfaceModul action setValue 0
						$extractSurfaceModul fire
						
						set newExtractedSurface [[lindex [$extractSurfaceModul downStreamConnections] 0 0] setLabel "$theLabel.surf"];# sets new name of the newly extracted surface (.surf is Amira standard for surface fields)
						
						lappend theExtractedSurfacesList $newExtractedSurface
							
						$newExtractedSurface master disconnect;# otherwise the newly created surface gets overriden in the next for loop iteration
						$newExtractedSurface recompute
						$newExtractedSurface cleanup
						$newExtractedSurface fixOrientation;# helps maybe
						# $newExtractedSurface makeOnePatch
						$newExtractedSurface compute
						$surfaceViewModul buffer setValue 2;# remove from buffer (hit remove button)
						$surfaceViewModul compute
						
					}
		
				
				}
				
				if { $theExtractedSurfacesList eq [list] } {# if list is empty echo warning, else process
					$this say "no labels for extraction selected"
				} else {
					
					lset theCompleteExtractedSurfacesList [concat $theCompleteExtractedSurfacesList $theExtractedSurfacesList];# save all generated surfaces in theCompleteExtractedSurfacesList list
					
					$surfaceViewModul buffer setValue 1;# only get rid of the last selection in buffer which would otherwise be visible in the viewer
					$surfaceViewModul compute
					
					# in this foreach iteration the surfaces in the theExtractedSurfacesList list will be further processed
					foreach theSurface $theExtractedSurfacesList {
						
						$this createModuleAndConnectIfOkToSource HxAlignPrincipalAxes $alignPrincipalAxesModul $theSurface
						$alignPrincipalAxesModul action setValue 0
						$alignPrincipalAxesModul fire
						
					}
				
				}
				
				remove $alignPrincipalAxesModul;# AlignPrincipalAxes module is not needed any more.
				set labfieldCount [incr labfieldCount]
			}
						
		}
		
		if { $myVoxelDataToggleIsChecked == 1 } {
		
			set theArithmeticExtractedSurfacesList [list]
			set labfieldCount 0
			
			foreach labelfield $allConnectedLabFields {
				
				$this testBreak
				
				$this createModuleAndConnectIfOkToSource HxArithmetic $arythmeticModul [$labelfield ImageData source];# connect a Arithmetic module to the voxelfield which connects to the labelfield
				$arythmeticModul inputB connect $labelfield;# connect inputB of Arithmetic module to the labelfield
			
				set theLabSetFromLabSetList [lindex $labSetList $labfieldCount];# the needed labSet port (e.g. labSet1, labSet2 ...)
				
				for { set i 0 } {$i < [$this $theLabSetFromLabSetList getNum] } { incr i } {
			
					$this testBreak;# maybe calculation here will take long
					
					if { [$this $theLabSetFromLabSetList getValue $i] == 1 } {
					
						$arythmeticModul expr setValue "\(A*\(B==$i\)\)";# sets the extraction expression
						$arythmeticModul doIt setValue 0;# sometimes it is called doIt, sometimes it is called action for running a amira module, so always look for right command!
						$arythmeticModul fire

						set theResultFromArithmeticCalcName [[lindex [$arythmeticModul downStreamConnections] 0 0] setLabel "[$labelfield parameters Materials index $i]"];# sets label for newly created voxelfield
						$theResultFromArithmeticCalcName master disconnect;# disconnect, otherwise the result from arithmetic module will be overridden
				
						# append extracted voxel field to global lists:
						lappend theCompleteExtractedSurfacesList $theResultFromArithmeticCalcName;
						lappend theArithmeticExtractedSurfacesList $theResultFromArithmeticCalcName;
						
					}
					
				}
				
				set labfieldCount [incr labfieldCount]	
			}
			
			
		}
		
		if { $myResampleZToggleIsChecked == 1 } {
			
		}
		
		if { [info exists labfieldCount] } { unset labfieldCount theLabSetFromLabSetList }
		
		workArea setProgressValue 1
		workArea stopWorking
					
	}

	
	
	# completion of compute procedure:
	if {$allConnectedLabFields eq "" && [$this getVar runCounter] > 0} {
			$this say "nothing to process - no label field connected"
	}
#	if {[lrange $resultSelectionState 3 5] eq [list 0 0 0] && [$this getVar runCounter] > 0} {
#			$this say "nothing to process - choose on ore more result options"
#	}
		
	$this setVar computeCounter [expr [$this getVar computeCounter] + 1];# computeCounter will get +1 for every run from compute proc
}
  
  