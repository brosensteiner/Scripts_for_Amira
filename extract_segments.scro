# Amira-Script-Object V3.0

source "[file dirname [info script]]/amira_procs.tcl";#relative path to amira_procs.tcl

# Register the packages
package require Tcl 8.4;# Amira 5.2.4 has Tcl 8.4 interpreter built in (patchlevel 8.4.19)

set moduleName [string map {"\.scro" ""} $this];# the name of the module generated from the script filename
set theAuthor "Bernhard Rosensteiner"

# definition of global variables:
$this setVar runCounter 0
$this setVar computeCounter 0

set theExtractedSurfacesList [list];# keeps track of surfaces of the current run
set theArithmeticExtractedVoxelList [list];# keeps track of all extracted surfaces from arithmetic runs
set theResampleZExtractedSurfacesList [list];# keeps track of all extracted surfaces from resample z runs
set theAdditionalDataList [list];#keeps track of additional data that $this produces (e.g. spreadsheet objects)
set volRenList [list];#$this maybe creats Volren modules and they will be collected in this list
set theCompleteExtractedList [list];# keeps track of all extracted surfaces from all runs

array set userLabListSelState {};# array for the selection state of user selected toggles
array set lastLabSetArray {};# array of all labels in last labSet
set labCountList [list];# count list of all lab gui toogles
set allConnectedLabFields [list];# list of all connection ports which have a source
set labSetList [list];# list of all lab sets which are in gui
set userResultSelState [list]
set userSaveState [list]
set emptyConPorts 0;# for counting empty connection ports of $this
set allEmptyConPorts [list];# all empty connction ports of $this
set labOKFlagList [list];# saves if labels are ok

# i dont´t want name clashes with user given names for modules
# so here are the hopefully cryptic enough generated names for the modules $this can creates:
set surfaceGenModul XxXSurfaceGen_${moduleName}
set surfaceViewModul XxXSurfaceView_${moduleName}
set extractSurfaceModul XxXextractSurface_${moduleName}
set alignPrincipalAxesModul XxXalignPrincipalAxes_${moduleName}
set arythmeticModul XxXArithmetic_${moduleName}
set shapeAnalysisModul XxXShapeAnalysis_${moduleName}

#
# ********** the amira script functions **********
#
$this proc constructor {} {

	# $this setNoSave 1;# $this can now correctly be saved with the network, so no need for this ...

	$this select;# $this should be selected after loading
	$this script show;# will be commented out when $this is finished, only handy for debbuging

	# creates options for choosing which result will be produced by $this
	$this newPortToggleList result 4
	$this result setLabel "Result"
	$this result setLabel 0 "overwrite"
	$this result setLabel 1 "polygon surface"
	$this result setLabel 2 "voxel data"
	$this result setLabel 3 "resample z"
	
	$this newPortFilename saveResults
	$this saveResults setLabel "Save result"
	$this saveResults setMode 3
	
	# creates a generic port for some stuff (maybe future extensions):
	$this newPortButtonList Utilities 1
	$this Utilities setLabel 0 "Connect all label fields"
	$this Utilities setCmd 0 { $this autoConnectToLabelField }
	
	# creates Action Button port
	$this newPortDoIt action
	$this action setLabel "Action"
	$this action setLabel 0 "Dolt"
	$this action hide;# actually need not be visible, because apply botton does the job

	# creates smoothing options:
	$this newPortSeparator smoothingSeparator
	$this newPortMultiMenu smoothing 3
	$this smoothing setLabel "Smoothing"
	$this smoothing setLabel 0 0 "none"
	$this smoothing setLabel 0 1 "constrained smoothing"
	$this smoothing setLabel 0 2 "unconstrained smoothing"
	
	$this newPortFloatSlider  SmoothingSliderPort
	$this SmoothingSliderPort setLabel "SmoothingKernelSize"
	$this SmoothingSliderPort setMinMax 1 9
	$this SmoothingSliderPort setFormat "%.2g"
	$this SmoothingSliderPort setNumColumns 3
	$this SmoothingSliderPort setValue 4;# initial value for smoothing slider. My tests have shown this is most of the time a good value
	$this SmoothingSliderPort setTracking 1
	
	# recreates the options port from SurfaceGen
	$this newPortToggleList options 2
	$this options setLabel "Options"
	$this options setLabel 0 "add border"
	$this options setLabel 1 "compactify"
	
	# recreates the options port from Arithmetic
	$this newPortSeparator voxelSeparator
	$this newPortToggleList voxelOptions 3
	$this voxelOptions setLabel "Voxel options"
	$this voxelOptions setLabel 0 "align principal axis"
	$this voxelOptions setLabel 1 "use mass"
	$this voxelOptions setLabel 2 "connect results to Volren"
	
	#creates colormap port for the volren modules when "connect results to Volren module" is checked \
	 this port will allow remote controlling of all volren modules in the pool which $this created
	$this newPortColormap colormap
	
	# creates resample z options
	$this newPortSeparator resampleSeparator
	$this newPortToggleList resampleOptions 2
	$this resampleOptions setLabel "Resample options"
	
	
	# when savedLabes is not defined it will with this if statement (will only be the case at first loading $this, \
	  afterwards it is always defined -> see proc savePreparation):
	if { ![$this hasVar savedLabels] } {# hasVar is undocumented in Amira documentation, but indispensable ...
		 $this setVar savedLabels 1
	}
	# this loop creates the needed dynamic gui elements (savedLabels global variable is the counter for how many will be created):
	for { set i 1 } { $i <= [$this getVar savedLabels] } { incr i } {
		$this createConPortButtonsToggles $i
	}
	
	$this sayHello;# when constuctor is loaded prints welcome message in console
		
}

$this proc destructor {} {
	
	global surfaceGenModul arythmeticModul shapeAnalysisModul
	global surfaceViewModul extractSurfaceModul
	global userLabListSelState lastLabSetArray allConnectedLabFields labCountList labOKFlagList
	global labSetList emptyConPorts allEmptyConPorts

	# removes the modules which the script eventually created when $this gets deleted:
	if { [lsearch [all] $surfaceGenModul] != -1 }		{ remove [$surfaceGenModul getResult]; remove $surfaceGenModul }
	if { [lsearch [all] $surfaceViewModul] != -1 }		{ remove $surfaceViewModul }
	if { [lsearch [all] $extractSurfaceModul] != -1 }	{ remove $extractSurfaceModul }
	if { [lsearch [all] $arythmeticModul] != -1 }		{ remove $arythmeticModul }
	if { [lsearch [all] $shapeAnalysisModul] != -1 }	{ remove $shapeAnalysisModul }
	
	# for safety, unset all global variables:
	if { [info exists userLabListSelState] }			{ unset userLabListSelState }
	if { [info exists allConnectedLabFields] }			{ unset allConnectedLabFields }
	if { [info exists labCountList] }					{ unset labCountList }
	if { [info exists labSetList] }						{ unset labSetList }
	if { [info exists emptyConPorts] }					{ unset emptyConPorts }
	if { [info exists allEmptyConPorts] }				{ unset allEmptyConPorts }
	if { [info exists labOKFlagList] }					{ unset labOKFlagList }
	
	set hideNewModules 0
	
}

$this proc savePreparation { args } {
	
	global allConnectedLabFields emptyConPorts
	# saves a counter which holds how many gui labset´s should be created after loading a network file again,
	# when $this is saved with a network file:
	$this setVar savedLabels [expr [llength $allConnectedLabFields] + $emptyConPorts]
	
}

$this proc compute {} {

	$this testBreak;# for safety...
	
	global moduleName theAuthor
	global surfaceViewModul extractSurfaceModul surfaceGenModul shapeAnalysisModul
	global theExtractedSurfacesList theCompleteExtractedList theArithmeticExtractedVoxelList theResampleZExtractedSurfacesList theAdditionalDataList volRenList
	global alignPrincipalAxesModul arythmeticModul
	global userLabListSelState userSaveState

	global allConnectedLabFields labCountList labOKFlagList
	global lastLabSetArray labSetList

	# some status checks on toogle bottons:
	set overwriteToggleIsChecked [$this result getValue 0]
	set polygonSurfaceToggleIsChecked [$this result getValue 1]
	set voxelDataToggleIsChecked [$this result getValue 2]
	set resampleZToggleIsChecked [$this result getValue 3]
	set resultSelectionState [$this result getState]
	
	set voxelOptionAlignPrincipalAxisIsChecked [$this voxelOptions getValue 0]
	set voxelOptionMassIsChecked [$this voxelOptions getValue 1]
	set voxelOptionConnectVolrenIsChecked [$this voxelOptions getValue 2]
	
	$this checkModuleStateAndSetVariables;
	
	if { [$this getVar computeCounter] > 0 } { $this conPortLogic };# procedure conPortLogic will be executed after the first compute run
	
	
	# the following if/elsif statements show/hide most of the gui when user checks the toggles or connects modules
	if { $polygonSurfaceToggleIsChecked } {# "polygon surface" is checked
			
		$this smoothingSeparator show
		$this smoothing show
		$this SmoothingSliderPort show
		$this options show
	} else {# "polygon surface" is not checked
	
		$this smoothingSeparator hide
		$this smoothing hide
		$this SmoothingSliderPort hide
		$this options hide
	}
	if { $voxelDataToggleIsChecked } {# "voxel data" is checked
			
		$this voxelSeparator show
		$this voxelOptions show
	} else {# "voxel data" is not checked
		
		$this voxelSeparator hide
		$this voxelOptions hide
	}
	if { $voxelOptionAlignPrincipalAxisIsChecked } {
	
		 	$this voxelOptions setSensitivity 1 1
		 } else {
		 
		 	$this voxelOptions setSensitivity 1 0
	}
	if { $resampleZToggleIsChecked } {# "resample z" is checked
			
		$this resampleSeparator show
		$this resampleOptions show
	} else {# "resample z" is not checked
		
		$this resampleSeparator hide
		$this resampleOptions hide
	}
	if { $voxelOptionConnectVolrenIsChecked } then { $this colormap show } else { $this colormap hide }
	
	# the next "if" is neccesary because i don´t get the interactive mapping of ports in amira to work (at least with colormap ports),\
	  so the eventually created volren modules get updated this way when the colormap port of $this will be modified by user:
	if { [$this colormap isNew] && [llength volRenList] != 0 } then {# when colormap port has changed and there is something in volRenList list
	
		foreach item $volRenList {
			$item color0 setState [$this colormap getState]
			$item compute
		}
	}
	
	# ********** actions ********** \
	  enters only here when "Apply" button ($this action port) of $this is pressed:
	
	if { ![$this action getValue] } {# start calculation when action button is pressed and $this has a valid source
	
		workArea startWorking
	
		$this setVar runCounter [expr [$this getVar runCounter] + 1];# sets the new runCounter + 1
		$this say "run [$this getVar runCounter]:"
		workArea setProgressInfo "starting calculation"
		workArea setProgressValue 0.4
		
		
		# if toggle "overwrite" is set and list is not empty the next statement deletes all previously by $this generated \
		  surface- voxel- and additional-data lists: 
		if { $overwriteToggleIsChecked == 1 && $theCompleteExtractedList ne [list] } {
		
			foreach surfaceToRemove $theCompleteExtractedList {
				remove $surfaceToRemove
			}
			foreach additionalData $theAdditionalDataList {
				remove $additionalData
			}
			foreach volRenModul $volRenList {
				remove $volRenModul
			}
			# delete all list elements:
			set theCompleteExtractedList [list]
			set theAdditionalDataList [list]
			set volRenList [list]
			$this say "old results overwritten"
			
		}
		
		if { $polygonSurfaceToggleIsChecked } {
			
			set labfieldCount 0;# counts only how often the foreach loop has run (is needed for retrieving the correct index from labSetList -> see below)
			
			foreach labelfield $allConnectedLabFields {
			
				$this testBreak
			
				$this createModuleAndConnectIfOkToSource HxGMC $surfaceGenModul $labelfield;# connect to labelfield
				
				$surfaceGenModul fire
				# SmoothKernelSize is a internal, but documented variable which i made visible in the gui, because it is sometimes useful for better quality of polygon surface generation
				$surfaceGenModul setVar SmoothKernelSize [$this SmoothingSliderPort getValue];
				
				# sets corresponding gui from $this for the SurfaceGen module:
				$this setCorrespondingPort surfaceGenModul options 0;
				$this setCorrespondingPort surfaceGenModul options 1;
				$this setCorrespondingPort surfaceGenModul smoothing;
								
				$surfaceGenModul action setValue 0;# calculate the polygon surface
				
				$surfaceGenModul fire
				
				# connect a SurfaceView module for selecting the user specified labels in buffer to the newly generated surface field from surfaceGenModul:
				$this createModuleAndConnectIfOkToSource HxDisplaySurface $surfaceViewModul [lindex [$surfaceGenModul downStreamConnections] 0 0]
						
				$surfaceViewModul compute
				$surfaceViewModul buffer setValue 2;# make shure buffer is empty for the first run (hits botton "clear")
				$surfaceViewModul compute
				
				
				set theExtractedSurfacesList [list]
				set theLabSetFromLabSetList [lindex $labSetList $labfieldCount];# the needed labSet port (e.g. labSet1, labSet2 ...)
				
				for { set i 0 } { $i < [$this $theLabSetFromLabSetList getNum] } { incr i } {
				
					$this testBreak
					
					if { [$this $theLabSetFromLabSetList getValue $i] == 1 } {
						
						set theLabel [$this $theLabSetFromLabSetList getLabel $i]
						
						$surfaceViewModul materials setValueString $theLabel
						$surfaceViewModul fire;# essential: all downStreamConnections must be updated!
						$surfaceViewModul buffer setValue 0;# add to buffer (hit add button)
						$surfaceViewModul compute
						
						# here happens the extraction of the surfaces:
						$this createModuleAndConnectIfOkToSource HxViewBaseExtract $extractSurfaceModul $surfaceViewModul;# createSurface command from HxDisplaySurface class\
						would also work, actually the createSurface command does the same in background but makes some overhead because of always deleting and creating\
						 a HxViewBaseExtract module for every extracted surface - createModuleAndConnectIfOkToSource does not
						$extractSurfaceModul action setValue 0
						$extractSurfaceModul fire
						
						set newExtractedSurface [[$extractSurfaceModul getResult] setLabel "$theLabel.surf"];# sets new name of the newly extracted surface (.surf is Amira standard for surface fields)
						#set newExtractedSurface [[$extractSurfaceModul getResult] getLabel];# amira gives automatic numbers to double entries in the pool so here i will get the actual label back
						
						# cleanup the label field parameters:
						array set newExtractedSurfaceParameters [$this makeArrayFromAmiraParameters $newExtractedSurface];# get the original values from the parameter list
						#echo "***[array get newExtractedSurfaceParameters]"
						
						# clearing the old parameters:
						$this clearBundle $newExtractedSurface Materials
						eval "$newExtractedSurface parameters Materials newBundle $theLabel"
						$newExtractedSurface setDefaultFileFormat "HxSurface ascii" 
						# adopting the values for the respective label:
						foreach item { Color Transparency id } {
							if { [info exists newExtractedSurfaceParameters(Materials,$theLabel,$item)] } {
								eval "$newExtractedSurface parameters Materials $theLabel setValue $newExtractedSurfaceParameters(Materials,$theLabel,$item)"
							}
						}
						#some additional info: 	
						$this stampField $newExtractedSurface ModuleInfo ModuleName $moduleName author $theAuthor
						
						lappend theExtractedSurfacesList $newExtractedSurface
						array unset newExtractedSurfaceParameters
							
						$newExtractedSurface master disconnect;# otherwise the newly created surface gets overriden in the next for loop iteration
						$newExtractedSurface cleanup
						$newExtractedSurface fixOrientation;# helps maybe
						#$newExtractedSurface makeOnePatch;# when not made the $newExtractedSurface is corrupt when not saved and openend again,\
						(i.e attaching a SurfaceView module crashes Amira) has propably something to do with changing values in the parameter list ... 
						$newExtractedSurface recompute
						$newExtractedSurface compute
						$surfaceViewModul buffer setValue 2;# remove from buffer (hit remove button)
						$surfaceViewModul compute
						
					}
				
				}

				lset theCompleteExtractedList [concat $theCompleteExtractedList $theExtractedSurfacesList];# save all generated surfaces in theCompleteExtractedList list
				
				$surfaceViewModul buffer setValue 1;# only get rid of the last selection in buffer which would otherwise be visible in the viewer
				$surfaceViewModul compute
				
				# in this foreach iteration the surfaces in the theExtractedSurfacesList will be rotated according to their respective principal axes:
				foreach theSurface $theExtractedSurfacesList {
					
					$this createModuleAndConnectIfOkToSource HxAlignPrincipalAxes $alignPrincipalAxesModul $theSurface
					$alignPrincipalAxesModul action setValue 0
					$alignPrincipalAxesModul fire
					
				}
				
				
				remove $alignPrincipalAxesModul;# AlignPrincipalAxes module is not needed any more.
				incr labfieldCount
			}
		}
		
		if { $voxelDataToggleIsChecked } {
		
			set theArithmeticExtractedVoxelList [list]
			set labfieldCount 0;#counter for foreach loop below
			set xCount 0;#this counter will keep track of the items in $theArithmeticExtractedVoxelList when a $theItemToTransform is needed in the foreach loop below
			
			foreach labelfield $allConnectedLabFields {
				
				$this testBreak
				
				$this createModuleAndConnectIfOkToSource HxArithmetic $arythmeticModul [$labelfield getControllingData];# connect a Arithmetic module to the voxelfield which connects to the labelfield
				$arythmeticModul inputB connect $labelfield;# connect inputB of Arithmetic module to the labelfield
			
				set theLabSetFromLabSetList [lindex $labSetList $labfieldCount];# the needed labSet port (e.g. labSet1, labSet2 ...)
				
				for { set i 0 } {$i < [$this $theLabSetFromLabSetList getNum] } { incr i } {
			
					$this testBreak;# maybe calculation here will take long
					
					if { [$this $theLabSetFromLabSetList getValue $i] == 1 && [lindex $labOKFlagList $labfieldCount] == 1 } {# check if toogle is checked and label field is ok
					
						$arythmeticModul expr setValue "\(A*\(B==$i\)\)";# sets the extraction expression
						$arythmeticModul doIt setValue 0;# sometimes it is called "doIt", sometimes it is called "action" for running a amira module, so always look for appropriate command!
						$arythmeticModul fire
						
						set theResultFromArithmeticCalcName [[$arythmeticModul getResult] setLabel "[$labelfield parameters Materials index $i].am"];# sets label for newly created voxelfield (.am is Amira standard fileformat for data objects)
						$theResultFromArithmeticCalcName master disconnect;# disconnect, otherwise the result from arithmetic module will be overridden
						$theResultFromArithmeticCalcName setUndefinedValue 0;#shure is shure ...
						
						#some additional info: 	
						$this stampField $theResultFromArithmeticCalcName ModuleInfo ModuleName $moduleName author $theAuthor
						
						# append extracted voxel field to global lists:
						lappend theCompleteExtractedList $theResultFromArithmeticCalcName;
						lappend theArithmeticExtractedVoxelList $theResultFromArithmeticCalcName;
						
					}
				}
				if { $voxelOptionAlignPrincipalAxisIsChecked } {
									
					for { set i 0 } {$i < [$this $theLabSetFromLabSetList getNum] } { incr i } {						
						
						if { [$this $theLabSetFromLabSetList getValue $i] == 1 && [lindex $labOKFlagList $labfieldCount] == 1} {
							
							# the shape analysis:
							array set valFromSprdsht [$this makeShapeAnalysis $labelfield $shapeAnalysisModul 1];
							
							set theItemToTransform [lindex $theArithmeticExtractedVoxelList $xCount];# get the needed item from list with xCount

							echo "[$theItemToTransform getTransform -d]"
							#eval "$theItemToTransform setRotation -center $valFromSprdsht($i,c) $valFromSprdsht($i,evector2) 90"
							
							eval "$theItemToTransform setTranslation [eval $this switchNumberSigns $valFromSprdsht($i,c)]";#translates center of object in 3D space to origin (i.e. 0, 0, 0)
							echo "theROTATION: [$theItemToTransform getRotation]"
							eval "$theItemToTransform rotate -wx 90"
							echo "[$theItemToTransform getTransform -d]"
							$theItemToTransform fire 
							incr xCount
						}
					}
				}
				incr labfieldCount
			}
			if { $voxelOptionConnectVolrenIsChecked } then {
				
				foreach item $theArithmeticExtractedVoxelList {
					set aNewVolrenModule [create HxVolren]
					lappend volRenList $aNewVolrenModule
					$aNewVolrenModule data connect $item

					$aNewVolrenModule color0 allowEditing 1
					#$aNewVolrenModule color0 connect $this colormap;#WHY IS IT NOT POSSIBLE TO DO THIS?, ACCORDING TO AMIRA DOCU IT SHOULD!!! -> always error
					$aNewVolrenModule color0 setState [$this colormap getState]
						
					#$this fire
					$aNewVolrenModule fire
				}
			}
			unset xCount labfieldCount
		}
		
		if { $resampleZToggleIsChecked } {
		
			
			
		}
		
		# saving routine:		
		if { $userSaveState ne "" } {# user has typed something in the saveResults port
			
			if { [file isdirectory $userSaveState] } {
			
				foreach result $theCompleteExtractedList {
					
					switch -exact [$result getTypeId] {
						HxUniformScalarField3 { $result save "Amiramesh ascii" $userSaveState/$result }
						HxSurface { $result save "HxSurface binary" $userSaveState/$result }
					}

				} 
				
			} else {
				$this say "whatever you typed in the \"[$this saveResults getLabel]\" field ... , it is not a valid directory name, so nothing has been saved"
			}
			
		}
		
		if { [info exists labfieldCount] } { unset labfieldCount theLabSetFromLabSetList }
		
		# user info which will be shown in the console if necessary:
		if { $allConnectedLabFields eq "" && [$this getVar runCounter] > 0 } {
			$this say "nothing to process - no label field connected"
		}
		if { [lrange $resultSelectionState 3 5] eq [list 0 0 0] && [$this getVar runCounter] > 0 } {
			$this say "nothing to process - choose on ore more result options"
		}
		foreach { key value } [array get userLabListSelState] {# searches if user has selected at least one label in the label sets
				
			regexp {(?:values\s\d)(.+)(?:isTristate)} $value myMatchedRegexp myMatchedRegexpSub
			if { ![regexp {1} $myMatchedRegexpSub] && [$this getVar runCounter] > 0 } {
				$this say "there are no labels selected for processing in \"[$this labSet$key getLabel]\""
			}
		
		}
		
		workArea setProgressValue 1
		workArea stopWorking
					
	}

		
	$this setVar computeCounter [expr [$this getVar computeCounter] + 1];# computeCounter will get +1 for every run from compute proc
}
  
