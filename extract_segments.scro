# Amira-Script-Object V3.0

# Register the packages
package require Tcl 8.4;# Amira 5.2.4 has Tcl 8.4 interpreter built in (patchlevel 8.4.19)

set moduleName [string map {"\.scro" ""} $this];# the name of the module generated from the script filename
set theAuthor "Bernhard Rosensteiner"

# definition of global variables:
$this setVar runCounter 0
$this setVar computeCounter 0

set theExtractedSurfacesList [list];# keeps track of surfaces of the current run
set theArithmeticExtractedSurfacesList [list];# keeps track of all extracted surfaces from arithmetic runs
set theResampleZExtractedSurfacesList [list];# keeps track of all extracted surfaces from resample z runs
set theCompleteExtractedList [list];# keeps track of all extracted surfaces from all runs

array set userLabListSelState {};# array for the selection state of user selected toggles 
array set lastLabSetArray {};# array of all labels in last labSet
set labCountList [list];# count list of all lab gui toogles
set allConnectedLabFields [list];# list of all connection ports which have a source
set labSetList [list];# list of all lab sets which are in gui
set userResultSelState [list]
set userSaveState [list]
set emptyConPorts 0;# for counting empty connection ports of $this
set labOKFlagList [list];# saves if labels are ok

# i dont´t want name clashes with user given names for modules
# so here are the hopefully cryptic enough generated names for the modules $this maybe creates:
set surfaceGenModul XxXSurfaceGen_${moduleName}
set surfaceViewModul XxXSurfaceView_${moduleName}
set extractSurfaceModul XxXextractSurface_${moduleName}
set alignPrincipalAxesModul XxXalignPrincipalAxes_${moduleName}
set arythmeticModul XxXArithmetic_${moduleName}

$this proc sayHello {} {
	global moduleName
	echo "\n************ module \"$moduleName\" loaded successfully :) ************\n"
}
$this proc say { something } {
	global moduleName
	echo "$moduleName: $something"
}
# procedure which can add new parameters to a amira field. 1. arg: the field, 2. arg: a new Bundle, args: pairs of parameter/values (e.g. Color { 1 0 1 })
$this proc stampField { field theBundle args } {

	$field parameters newBundle $theBundle
	foreach { par val } $args {
		eval "$field parameters $theBundle setValue $par $val"
	}

}
# clear items in a specified Bundle in a amira field (saves some typing):
$this proc clearBundle { field args } {

	if { [llength $args] > 1 } {
		set lastElement [lindex $args end]
		set restElements [lrange $args 0 end-1]
	} else {# when only one bundle in args (e.g. Materials)
		set lastElement $args
		set restElements ""
	}
	
	foreach item [eval "$field $restElements parameters $lastElement list"] {
		eval "$field $restElements parameters $lastElement $item setFlag NO_DELETE 0"
		eval "$field $restElements parameters $lastElement remove $item"
	}
	
}


# simple port test: procedure returns 1 when modul has port, otherwise it returns 0
$this proc hasPort {modul port} {
	upvar #1 $modul myModule
	if { [lsearch [$myModule allPorts] $port] != -1 } { return 1 } else { return 0 }
}

# procedure which returns all parameters of a given amira field in a formatted array, were every parameter/value can be retrieved  (procedure is needed, because amira´s tcl interface can´t do it in one step) \
  amira field parameter lists are not that big, so this recursive approach should make not to much overhead. \
  procedure needs a the only argument a amira field (e.g. label field)
$this proc makeArrayFromAmiraParameters { field { theComplValArr {} } { concatBundles {} } { recloop 0 } } {
		
	upvar 1 $theComplValArr theComplValArrUpvar;# this is neccesary because theComplValArrUpvar should always point one level up (yeah! Tcl has pointers ;)) to theComplValArr,\
	 so that theComplValArr gets every time modified even the recursion is in a stackframe deeper
		
	if { [llength concatBundles] == 0 } {
	
		set theList [eval "$field parameters list"]
		if { [llength $theList] == 0 } { echo "$field has no parameters"; return 1 }
		
	} else { set theList [eval "$field parameters [join $concatBundles] list"] }
	
	foreach element $theList {
		
		if { [eval "$field parameters [join $concatBundles] $element isBundle"] } {
			
			$this makeArrayFromAmiraParameters $field theComplValArrUpvar [concat $concatBundles $element] [incr recloop]
			
		} else {
		
			set theValue [eval "$field parameters [join $concatBundles] $element getValue"]
			if { ![info exists theComplValArrUpvar([join $concatBundles ,],$element)] } {
				 set theComplValArrUpvar([join $concatBundles ,],$element) [list $element $theValue]
			} else { 
				echo "$theComplValArrUpvar([join $concatBundles ,],$element) exists already in parameter list, so it gets a name modifier!"
				set theComplValArrUpvar([join $concatBundles ,],$element$recloop) [list $element $theValue]
			}
			
		}
		
	}
	return [array get theComplValArrUpvar]
	
}

$this proc autoConnectToLabelField {} {

	global allConnectedLabFields allEmptyConPorts
	
	set theLabConPortsList [lrange [$this connectionPorts] 1 end]
	set theList [all HxUniformLabelField3]
	
	foreach item $theLabConPortsList {
		$this $item disconnect
	}
	
	foreach item $theList {
		$this [lindex $allEmptyConPorts 0] connect $item
		$this compute
	}
}

# function which checks on some $this states, so every time something happens with $this
# it knows it´s actual state and it can be asked about it:
$this proc checkModuleStateAndSetVariables {} {

	global allConnectedLabFields allEmptyConPorts labCountList
	global lastLabSetArray userLabListSelState labSetList emptyConPorts labOKFlagList
	global userResultSelState userSaveState
	
	$this fire
	
	# first make all empty:
	array unset userLabListSelState
	array unset lastLabSetArray
	set allConnectedLabFields [list]
	set allEmptyConPorts [list]
	set labCountList [list]
	set labSetList [list]
	set emptyConPorts 0
	set labOKFlagList [list]
	
	# and then update again the lists/arrays:
	for { set i 1 } { $i < [llength [$this connectionPorts]] } { incr i } {
	
		if { [$this  [lindex [$this connectionPorts] $i] source] ne "" } {
			
			if { [[$this  [lindex [$this connectionPorts] $i] source] getControllingData] eq "" } {# test if label field has a image data field attached (e.g. needed for arithmetic calculations)
				$this say "warning! [$this  [lindex [$this connectionPorts] $i] source] has no image data field connected,\nfor processing of \"[$this result getLabel 2]\" and \"[$this result getLabel 2]\" results this is required"
				lappend labOKFlagList 0
			} else { lappend labOKFlagList 1 }
			
			lappend allConnectedLabFields [$this [lindex [$this connectionPorts] $i] source]
			lappend labCountList [[$this labFieldPortCon$i source] parameters Materials nBundles]
			lappend labSetList labSet$i
			set userLabListSelState($i) [$this labSet$i getState]
			
			for { set x 0 } { $x < [$this labSet$i getNum] } { incr x } {
				set lastLabSetArray([expr $x + 1]) [$this labSet$i getLabel $x]
			}

			# show the ports when connected to label field:
			$this labSeparator$i show
			$this labSetSelBottons$i show
			$this labSet$i show
			
		} else {
			
			set emptyConPorts [incr emptyConPorts];# count every empty connection port
			lappend allEmptyConPorts [lindex [$this connectionPorts] $i]
			
			# hide the ports when not connected to label field:
			$this labSeparator$i hide
			$this labSetSelBottons$i hide
			$this labSet$i hide
			
		}
		
	}
	
	# saving states for the static gui elements:
	set userResultSelState [$this result getState]
	set userSaveState [$this saveResults getState]
	
	# this loop sets the labels for each dynamic toggle in labSet ports:
	for { set x 1 } { $x < [llength [$this connectionPorts]] } { incr x } {
	
		if { [$this labFieldPortCon$x isNew] == 1 && [$this labFieldPortCon$x source] ne ""  } {#set the labels only new when connection port is new - reduces overhead
					
			$this labSet$x setNum [[$this labFieldPortCon$x source] parameters Materials nBundles];# get the number of material from the source and set number of toogles
			for { set y 0 } { $y < [$this labSet$x getNum] } { incr y } {
				$this labSet$x setLabel $y [lindex [[$this labFieldPortCon$x source] parameters Materials list] $y]
			}
			
		}
		
	}
	
	
	# printing $this info (only for debugging):
	$this say "\nuserLabListSelState: [array get userLabListSelState]"
	$this say "lastLabSetArray: [array get lastLabSetArray]"
	$this say "allConnectedLabFields: $allConnectedLabFields"
	$this say "allEmptyConPorts: $allEmptyConPorts"
	$this say "emptyConPorts: $emptyConPorts"
	$this say "labOKFlagList: $labOKFlagList"
	$this say "labCountList: $labCountList"
	$this say "labSetList: $labSetList"
	$this say "userResultSelState: $userResultSelState"
	$this say "userSaveState: $userSaveState\n"
	
}

# procedure which will be executed when a "None" button is pressed
$this proc bottonNonePressed { num } {
	
	for { set i 0 } { $i <= [$this labSet$num getNum] } { incr i } {
		$this labSet$num setValue $i 0
	}
 	$this checkModuleStateAndSetVariables
 			
}
# procedure which will be executed when a "All" button is pressed
$this proc bottonAllPressed { num } {
 	
	for { set i 0 } { $i <= [$this labSet$num getNum] } { incr i } {
		$this labSet$num setValue $i 1
	}
	$this checkModuleStateAndSetVariables;
  			
}

# procedure creates gui elements (separator, bottons, toggles) for a connected lab field
# argument i is the number of portname
$this proc createConPortButtonsToggles { i } {

	global allConnectedLabFields labCountList
	global lastLabSetArray labSetList
	global userLabListSelState userResultSelState userSaveState emptyConPorts
		
	$this newPortConnection labFieldPortCon$i HxUniformLabelField3
	
	# creates gui for material selection toggles:
	$this newPortSeparator labSeparator$i
	$this newPortButtonList labSetSelBottons$i 2
	$this labSetSelBottons$i setLabel "Selection $i"
	$this labSetSelBottons$i setLabel 0 "None"
	$this labSetSelBottons$i setLabel 1 "All"
	$this newPortToggleList labSet$i 0;# only init, right toggles numbers will be determind when label field is connected
	$this labSet$i setLabel "Label set $i"
	
	# build strings for setCmc commands, because $i has to be evaluated before it is given as argument for setCmd
	# every new botton set will get a individual procedure assigned (which will be executed every time a "None" or "All" botton is pressed),
	# because $i changes with every run of createConPortButtonsToggles procedure
	eval "\$this labSetSelBottons\$i setCmd 0 \{ \$this bottonNonePressed " "$i \}"
	eval "\$this labSetSelBottons\$i setCmd 1 \{ \$this bottonAllPressed " "$i \}"
	
	# ports should initially hidden:
	$this labSeparator$i hide
	$this labSetSelBottons$i hide
	$this labSet$i hide
	
	$this checkModuleStateAndSetVariables;
	
}
# procedure deletes gui elements (separator, bottons, toggles) for a connected lab field
# argument i is the number of portname
$this proc deleteConPortButtonsToggles { i } {
		
	$this deletePort labFieldPortCon$i
	$this deletePort labSeparator$i
	$this deletePort labSetSelBottons$i
	$this deletePort labSet$i
	
	$this checkModuleStateAndSetVariables;
	
}

# procedure which will make shure that there is always a free connection port for connecting a label field
# all connection ports at the end will be deleted if there is a free connection port somewhere in the middle
# (is a smarter logic that for example the amira´s own ExtractSurface module has)
$this proc conPortLogic {} {

	global emptyConPorts
	
	# create new connecton port when the last connecton port in the list has connected a label field:
	if { [$this [lindex [$this connectionPorts] end] source] ne "" && $emptyConPorts == 0 } {
		
		$this createConPortButtonsToggles [llength [$this connectionPorts]];
	}
	# delete all connection ports beginning at the end until the first connction port with a connected label field is found:
	for { set i 0 } { $i < [llength [$this connectionPorts]] } { incr i } {
	
		if { [$this [lindex [$this connectionPorts] end] source] eq "" && $emptyConPorts > 1 } {
			$this deleteConPortButtonsToggles [expr [llength [$this connectionPorts]] - 1];
		}
		
	}

}

# procedure which creates moduleType and connects it with sourceName module and checks if connection is valid
# moduleName is the name of the module in the pool
# if moduleName module does not exist it also gets created in the pool
# function returns the name string of the newly created module
$this proc createModuleAndConnectIfOkToSource { moduleType moduleName sourceName { conPortIndex 0 } } {

	
	if { [lsearch [all $moduleType] $moduleName] == -1 } {# test if module is already in the pool -1 := not in pool
	
		 	set returnedModule [create $moduleType $moduleName]
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex];# sets the desired connectionPort name, default is 0
		 	if { [$moduleName $theConnectionPort validSource $sourceName] == 1 } {
		 		if { [$moduleName $theConnectionPort source] ne $sourceName } { $moduleName $theConnectionPort connect $sourceName };
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
		 } else {
		 	
		 	set returnedModule $moduleName
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex]
		 	if { [$moduleName $theConnectionPort validSource $sourceName] == 1 } {
		 		if { [$moduleName $theConnectionPort source] ne $sourceName } { $moduleName $theConnectionPort connect $sourceName };
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
	}
	
	return $returnedModule
	
}

# switches the given module port remotely from $this ($this must have a corresponding (i.e. same) port!)
# it works like the amira built in port connect "<modulename 1> <P0 name> connect < modulename 2> [<P1 name>]" exept, that it works (e.g. there are some bugs with menu entry numeration in amira modules)
$this proc setCorrespondingPort { module port { portIndex 0 } } {

	upvar #0 $module myModule
	
	if { [info exists myModule] == 0 } {
		$this say "hm\.\.\. this module does not exist, maybe you deleted it - restart $moduleName"
	}
	
	$this fire;# infinit loop in Amira when here no update of all downstream modules - crashes most of the time Amira
	
	switch -exact [$this $port getTypeId] {
		HxPortMultiMenu { $myModule $port setValueString $portIndex [$this $port getLabel [$this $port getValue $portIndex]] }
		HxPortToggleList { $myModule $port setValue  $portIndex [$this $port getValue $portIndex] }
		default { $this say "proc setCorrespondingPort: could not find a corresponding port" }
	};# setValueString is more robust than index counting with setValue
	
	$myModule compute

}


#
# ******************** the script loops ********************
#
$this proc constructor {} {

	# $this setNoSave 1;# $this can now correctly be saved with the network, so no need for this ...

	$this sayHello
	$this select;# $this should be selected after loading
	$this script show;# will be commented out when $this is finished, only handy for debbuging

	# creates options for choosing which result will be produced by $this
	$this newPortToggleList result 4
	$this result setLabel "Result"
	$this result setLabel 0 "overwrite"
	$this result setLabel 1 "polygon surface"
	$this result setLabel 2 "voxel data"
	$this result setLabel 3 "resample z"
	
	$this newPortFilename saveResults
	$this saveResults setLabel "Save result"
	$this saveResults setMode 3
	
	# creates a generic port for some stuff (maybe future extensions):
	$this newPortButtonList Utilities 1
	$this Utilities setLabel 0 "Connect all label fields"
	$this Utilities setCmd 0 { $this autoConnectToLabelField }
	
	# creates Action Button port
	$this newPortDoIt action
	$this action setLabel "Action"
	$this action setLabel 0 "Dolt"
	$this action hide;# actually need not be visible, because apply botton does the job

	# creates smoothing options:
	$this newPortSeparator smoothingSeparator
	$this newPortMultiMenu smoothing 3
	$this smoothing setLabel "Smoothing"
	$this smoothing setLabel 0 0 "none"
	$this smoothing setLabel 0 1 "constrained smoothing"
	$this smoothing setLabel 0 2 "unconstrained smoothing"
	
	$this newPortFloatSlider  SmoothingSliderPort
	$this SmoothingSliderPort setLabel "SmoothingKernelSize"
	$this SmoothingSliderPort setMinMax 1 9
	$this SmoothingSliderPort setFormat "%.2g"
	$this SmoothingSliderPort setNumColumns 3
	$this SmoothingSliderPort setValue 4;# initial value for smoothing slider. My tests have shown this is most of the time a good value
	$this SmoothingSliderPort setTracking 1
	
	# recreates the options port from SurfaceGen
	$this newPortToggleList options 2
	$this options setLabel "Options"
	$this options setLabel 0 "add border"
	$this options setLabel 1 "compactify"
	
	# recreates the options port from Arithmetic
	$this newPortSeparator voxelSeparator
	$this newPortToggleList voxelOptions 1
	$this voxelOptions setLabel "Voxel options"
	$this voxelOptions setLabel 0 "align principal axis"
	
	# creates resample z options
	$this newPortSeparator resampleSeparator
	$this newPortToggleList resampleOptions 2
	$this resampleOptions setLabel "Resample options"
	
		
	# when savedLabes is not defined it will with this if statement (will only be the case at first loading $this,
	# afterwards it is always defined -> see proc savePreparation):
	if { ![$this hasVar savedLabels] } {# hasVar is undocumented in Amira ducomentation, but indispensable ...
		 $this setVar savedLabels 1
	}
	# this loop creates the needed dynamic gui elements (savedLabels global variable is the counter for how many will be created):
	for { set i 1 } { $i <= [$this getVar savedLabels] } { incr i } {
		$this createConPortButtonsToggles $i
	}
		
}
  

$this proc destructor {} {
	
	global surfaceGenModul arythmeticModul
	global surfaceViewModul extractSurfaceModul
	global userLabListSelState lastLabSetArray allConnectedLabFields labCountList labOKFlagList
	global labSetList emptyConPorts

	# removes the modules which the script eventually created when $this gets deleted:
	if { [lsearch [all] $surfaceGenModul] != -1 }		{ remove [$surfaceGenModul getResult]; remove $surfaceGenModul }
	if { [lsearch [all] $surfaceViewModul] != -1 }		{ remove $surfaceViewModul }
	if { [lsearch [all] $extractSurfaceModul] != -1 }	{ remove $extractSurfaceModul }
	if { [lsearch [all] $arythmeticModul] != -1 }		{ remove $arythmeticModul }
	
	# for safty unset all global variables:
	if { [info exists userLabListSelState] }			{ unset userLabListSelState }
	if { [info exists allConnectedLabFields] }			{ unset allConnectedLabFields }
	if { [info exists labCountList] }					{ unset labCountList }
	if { [info exists labSetList] }						{ unset labSetList }
	if { [info exists emptyConPorts] }					{ unset emptyConPorts }
	if { [info exists labOKFlagList] }				{ unset labOKFlagList }
	
	set hideNewModules 0
	
}

$this proc savePreparation { args } {

	global allConnectedLabFields emptyConPorts
	# saves a counter which holds how many gui labset´s should be created after loading a network file,
	# when $this is saved with a network file:
	$this setVar savedLabels [expr [llength $allConnectedLabFields] + $emptyConPorts]
	
}

$this proc compute {} {

	$this testBreak;# for safety...
	
	global moduleName theAuthor surfaceGenModul
	global surfaceViewModul
	global extractSurfaceModul
	global theExtractedSurfacesList theCompleteExtractedList theArithmeticExtractedSurfacesList theResampleZExtractedSurfacesList
	global alignPrincipalAxesModul arythmeticModul
	global userLabListSelState userSaveState

	global allConnectedLabFields labCountList labOKFlagList
	global lastLabSetArray labSetList

	# some status checks on toogle bottons:
	set overwriteToggleIsChecked [$this result getValue 0]
	set polygonSurfaceToggleIsChecked [$this result getValue 1]
	set voxelDataToggleIsChecked [$this result getValue 2]
	set resampleZToggleIsChecked [$this result getValue 3]
	set resultSelectionState [$this result getState]
	
	set voxelOptionAlignPrincipalAxisIsChecked [$this voxelOptions getValue 0]
	
	$this checkModuleStateAndSetVariables;
	
	if { [$this getVar computeCounter] > 0 } { $this conPortLogic };# procedure conPortLogic will be executed after the first compute run
	
	
	# the following if/elsif statements construct most of the gui when user checks the toggles or connects modules
	if { $polygonSurfaceToggleIsChecked } {# "polygon surface" is checked
			
		$this smoothingSeparator show
		$this smoothing show
		$this SmoothingSliderPort show
		$this options show
				
				
	} else {# "polygon surface" is not checked
	
		$this smoothingSeparator hide
		$this smoothing hide
		$this SmoothingSliderPort hide
		$this options hide
		
	}
	if { $voxelDataToggleIsChecked } {# "voxel data" is checked
			
		$this voxelSeparator show
		$this voxelOptions show
				
				
	} else {# "voxel data" is not checked
		# TODO: here comes code when "voxel data" is not checked
		$this voxelSeparator hide
		$this voxelOptions hide
		
	}
	if { $resampleZToggleIsChecked } {# "resample z" is checked
			
		$this resampleSeparator show
		$this resampleOptions show
				
	} else {# "resample z" is not checked
		# TODO: here comes code when "resample z" is not checked
		
		$this resampleSeparator hide
		$this resampleOptions hide
		
	}
	
	
	# ********** actions **********
	# enters only here when "Apply" button ($this action port) of $this is pressed:
	
	if { ![$this action getValue] } {# start calculation when action button is pressed and $this has a valid source
	
		workArea startWorking
	
		$this setVar runCounter [expr [$this getVar runCounter] + 1];# sets the new runCounter + 1
		$this say "run [$this getVar runCounter]:"
		workArea setProgressInfo "starting calculation"
		workArea setProgressValue 0.4
		
		
		# if toggle "overwrite" is set and list is not empty the next statement deletes all previously by $this generated surfaces:
		if { $overwriteToggleIsChecked == 1 && $theCompleteExtractedList ne [list] } {
		
			foreach surfaceToRemove $theCompleteExtractedList {
				remove $surfaceToRemove
			}
			lset theCompleteExtractedList [list];# delete all list elements
			$this say "old results overwritten"
			
		}
		
		if { $polygonSurfaceToggleIsChecked } {
			
			set labfieldCount 0;# counts only how often the foreach loop has run (is needed for retrieving the correct index from labSetList -> see below)
			
			foreach labelfield $allConnectedLabFields {
			
				$this testBreak
			
				$this createModuleAndConnectIfOkToSource HxGMC $surfaceGenModul $labelfield;# connect to labelfield
				
				$surfaceGenModul fire
				# SmoothKernelSize is a internal, but documented variable which i made visible in the gui, because it is sometimes useful for better quality of polygon surface generation
				$surfaceGenModul setVar SmoothKernelSize [$this SmoothingSliderPort getValue];
				
				# sets corresponding gui from $this for the SurfaceGen module:
				$this setCorrespondingPort surfaceGenModul options 0;
				$this setCorrespondingPort surfaceGenModul options 1;
				$this setCorrespondingPort surfaceGenModul smoothing;
								
				$surfaceGenModul action setValue 0;# calculate the polygon surface
				
				$surfaceGenModul fire
				
				# connect a SurfaceView module for selecting the user specified labels in buffer to the newly generated surface field from surfaceGenModul:
				$this createModuleAndConnectIfOkToSource HxDisplaySurface $surfaceViewModul [lindex [$surfaceGenModul downStreamConnections] 0 0]
						
				$surfaceViewModul compute
				$surfaceViewModul buffer setValue 2;# make shure buffer is empty for the first run (hits botton "clear")
				$surfaceViewModul compute
				
				
				
				set theExtractedSurfacesList [list]
				set theLabSetFromLabSetList [lindex $labSetList $labfieldCount];# the needed labSet port (e.g. labSet1, labSet2 ...)
				
				for { set i 0 } { $i < [$this $theLabSetFromLabSetList getNum] } { incr i } {
				
					$this testBreak
					
					if { [$this $theLabSetFromLabSetList getValue $i] == 1 } {
						
						set theLabel [$this $theLabSetFromLabSetList getLabel $i]
						
						$surfaceViewModul materials setValueString $theLabel
						$surfaceViewModul fire;# essential: all downStreamConnections must be updated!
						$surfaceViewModul buffer setValue 0;# add to buffer (hit add button)
						$surfaceViewModul compute
						
						# here happens the extraction of the surfaces:
						$this createModuleAndConnectIfOkToSource HxViewBaseExtract $extractSurfaceModul $surfaceViewModul;# createSurface command from HxDisplaySurface class\
						would also work, actually the createSurface command does the same in background but makes some overhead because of always deleting and creating\
						 a HxViewBaseExtract module for every extracted surface - createModuleAndConnectIfOkToSource does not
						$extractSurfaceModul action setValue 0
						$extractSurfaceModul fire
						
						set newExtractedSurface [[$extractSurfaceModul getResult] setLabel "$theLabel.surf"];# sets new name of the newly extracted surface (.surf is Amira standard for surface fields)
						#set newExtractedSurface [[$extractSurfaceModul getResult] getLabel];# amira gives automatic numbers to double entries in the pool so here i will get the actual label back
						
						# cleanup the label field parameters:
											
						array set newExtractedSurfaceParameters [$this makeArrayFromAmiraParameters $newExtractedSurface];# get the original values from the parameter list
						# clearing the old parameters:
						$this clearBundle $newExtractedSurface Materials 
						$newExtractedSurface parameters Materials newBundle $theLabel
						$newExtractedSurface setDefaultFileFormat "HxSurface ascii" 
						# adopting the values for the respective label:
						foreach item { Color Transparency id } {
							eval "$newExtractedSurface parameters Materials $theLabel setValue $newExtractedSurfaceParameters(Materials,$theLabel,$item)"
						}
						#some additional info: 	
						$this stampField $newExtractedSurface ModuleInfo ModuleName $moduleName author $theAuthor
						
						lappend theExtractedSurfacesList $newExtractedSurface
							
						$newExtractedSurface master disconnect;# otherwise the newly created surface gets overriden in the next for loop iteration
						$newExtractedSurface recompute
						$newExtractedSurface cleanup
						$newExtractedSurface fixOrientation;# helps maybe
						$newExtractedSurface makeOnePatch;# when not made the $newExtractedSurface is corrupt when not saved and openend again,\
						(i.e attaching a SurfaceView module crashes Amira) has propably something to do with changing values in the parameter list ... 
						$newExtractedSurface compute
						$surfaceViewModul buffer setValue 2;# remove from buffer (hit remove button)
						$surfaceViewModul compute
						
					}
		
				
				}

				lset theCompleteExtractedList [concat $theCompleteExtractedList $theExtractedSurfacesList];# save all generated surfaces in theCompleteExtractedList list
				
				$surfaceViewModul buffer setValue 1;# only get rid of the last selection in buffer which would otherwise be visible in the viewer
				$surfaceViewModul compute
				
				# in this foreach iteration the surfaces in the theExtractedSurfacesList will be rotated according to their respective principal axes:
				foreach theSurface $theExtractedSurfacesList {
					
					$this createModuleAndConnectIfOkToSource HxAlignPrincipalAxes $alignPrincipalAxesModul $theSurface
					$alignPrincipalAxesModul action setValue 0
					$alignPrincipalAxesModul fire
					
				}
				
				
				remove $alignPrincipalAxesModul;# AlignPrincipalAxes module is not needed any more.
				set labfieldCount [incr labfieldCount]
			}
						
		}
		
		if { $voxelDataToggleIsChecked } {
		
			set theArithmeticExtractedSurfacesList [list]
			set labfieldCount 0
			
			foreach labelfield $allConnectedLabFields {
				
				$this testBreak
				
				$this createModuleAndConnectIfOkToSource HxArithmetic $arythmeticModul [$labelfield getControllingData];# connect a Arithmetic module to the voxelfield which connects to the labelfield
				$arythmeticModul inputB connect $labelfield;# connect inputB of Arithmetic module to the labelfield
			
				set theLabSetFromLabSetList [lindex $labSetList $labfieldCount];# the needed labSet port (e.g. labSet1, labSet2 ...)
				
				for { set i 0 } {$i < [$this $theLabSetFromLabSetList getNum] } { incr i } {
			
					$this testBreak;# maybe calculation here will take long
					
					if { [$this $theLabSetFromLabSetList getValue $i] == 1 && [lindex $labOKFlagList $labfieldCount] == 1} {# check if toogle is checked and label field is ok
					
						$arythmeticModul expr setValue "\(A*\(B==$i\)\)";# sets the extraction expression
						$arythmeticModul doIt setValue 0;# sometimes it is called "doIt", sometimes it is called "action" for running a amira module, so always look for right command!
						$arythmeticModul fire

						set theResultFromArithmeticCalcName [[$arythmeticModul getResult] setLabel "[$labelfield parameters Materials index $i].am"];# sets label for newly created voxelfield (.am is Amira standard fileformat for data objects)
						$theResultFromArithmeticCalcName master disconnect;# disconnect, otherwise the result from arithmetic module will be overridden
				
						# append extracted voxel field to global lists:
						lappend theCompleteExtractedList $theResultFromArithmeticCalcName;
						lappend theArithmeticExtractedSurfacesList $theResultFromArithmeticCalcName;
						
					}
					if { $voxelOptionAlignPrincipalAxisIsChecked } {
						
						
						
					}
	
				}
				set labfieldCount [incr labfieldCount]	
			}
			
		}
		
		if { $resampleZToggleIsChecked } {
		
			
			
		}
		
		# saving routine:		
		if { $userSaveState ne "" } {# is user has typed something in the saveResults port
			
			if { [file isdirectory $userSaveState] } {
			
				foreach result $theCompleteExtractedList {
					
					switch -exact [$result getTypeId] {
						HxUniformScalarField3 { $result save "Amiramesh ascii" $userSaveState/$result }
						HxSurface { $result save "HxSurface binary" $userSaveState/$result }
					}

				} 
				
			} else {
				$this say "whatever you typed in the \"[$this saveResults getLabel]\" field ... , it is not a valid directory name, so nothing has been saved"
			}
			
		}
		
		
		if { [info exists labfieldCount] } { unset labfieldCount theLabSetFromLabSetList }
		
		# user info which will be shown in the console if necessary:
		if {$allConnectedLabFields eq "" && [$this getVar runCounter] > 0} {
					$this say "nothing to process - no label field connected"
		}
		if {[lrange $resultSelectionState 3 5] eq [list 0 0 0] && [$this getVar runCounter] > 0} {
				$this say "nothing to process - choose on ore more result options"
		}
		foreach { key value } [array get userLabListSelState] {# searches if user has selected at least one label in the label sets
				
			regexp {(?:values\s\d)(.+)(?:isTristate)} $value myMatchedRegexp myMatchedRegexpSub
			if { ![regexp {1} $myMatchedRegexpSub] && [$this getVar runCounter] > 0 } {
				$this say "there are no labels selected for processing in \"[$this labSet$key getLabel]\""
			}
		
		}
		
		workArea setProgressValue 1
		workArea stopWorking
					
	}

		
	$this setVar computeCounter [expr [$this getVar computeCounter] + 1];# computeCounter will get +1 for every run from compute proc
}
  
  