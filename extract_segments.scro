# Amira-Script-Object V3.0

set moduleName [string map {"\.scro" ""} $this]

#definition of global variables:
$this setVar runCounter 0
set theExtractedSurfacesList [list];#keeps track of surfaces of the current run
set theArithmeticExtractedSurfacesList [list];#keeps track of all extracted surfaces from arithmetic runs
set theResampleZExtractedSurfacesList [list];#keeps track of all extracted surfaces from resample z runs
set theCompleteExtractedSurfacesList [list];#keeps track of all extracted surfaces from all runs


set userLabelListSelection1 [list]
set userLabelListSelection2 [list]
array set myMaterialsList  {1 ""}
array set myMaterialCount  {1 ""}
array set allConPorts  {1 ""}
array set materialSeparator {1 ""}
array set  LabSet {1 ""}
array set  labSetButtons {1 ""}


#i dont´t want name clashes with user given names for modules so here are the hopefully cryptic enough generated names for the modules $this maybe creates
set surfaceGen1Modul XxXSurfaceGen1_${moduleName}
set surfaceGen2Modul XxXSurfaceGen2_${moduleName}
set surfaceView1Modul XxXSurfaceView1_${moduleName}
set surfaceView2Modul XxXSurfaceView2_${moduleName}
set extractSurface1Modul XxXextractSurface1_${moduleName}
set extractSurface2Modul XxXextractSurface2_${moduleName}
set alignPrincipalAxesModul XxXalignPrincipalAxes_${moduleName}
set arythmeticModul XxXArithmetic_${moduleName}

$this proc sayHello {} {
	global moduleName
   echo "\n************ module \"$moduleName\" loaded successfully :) ************\n"
}
$this proc say {something} {
	global moduleName
	echo "$moduleName: $something"
}

#function which checks on some $this states and saves some typing:
$this proc checkModuleStateAndSetVariables {} {

	global allConPorts myMaterialsList myMaterialCount
	global materialSeparator LabSet labSetButtons
	#unset allConPorts myMaterialsList myMaterialCount
	
	
	$this fire
	
	for {set i 1} { $i < [llength [$this connectionPorts]] } {incr i} {
		
		$this say "connectionPorts [llength [$this connectionPorts]]"
		
		
		
		if {[$this [lindex [$this connectionPorts] $i] source] ne ""} {
		
			$this say "STATE new connected: [$this [lindex [$this connectionPorts] $i] source]\n"
			
			set allConPorts($i) [lindex [$this connectionPorts] $i]
			set materialSeparator($i) materialSeparator$i
			set LabSet($i) labSet$i
			set labSetButtons($i) labSetButtons$i
			
			set myMaterialsList($i)  [[$this [lindex [$this connectionPorts] $i] source] parameters Materials list]
			set myMaterialCount($i) [llength $myMaterialsList($i)]
			
		}
		
		echo "\n********\n"
		$this say "STATE array of myMaterialsList: [array get myMaterialsList]"
		$this say "STATE array of myMaterialCount: [array get myMaterialCount]"
		$this say "STATE array of allConPorts: [array get allConPorts]"
		$this say "STATE array of materialSeparator: [array get materialSeparator]"
		$this say "STATE array of LabSet: [array get LabSet]"
		
	}
	
}

#function which creates moduleType and connects it with sourceName module and checks if connection is valid
#moduleName is the name of the module in the pool
#if moduleName module does not exist it also gets created in the pool
#function returns the name string of the newly created module
$this proc createModuleAndConnectIfOkToSource {moduleType moduleName sourceName {conPortIndex 0}} {

	
	if {[lsearch -exact [all $moduleType] $moduleName] == -1} {#test if module is already in the pool -1 := not in pool
	
		 	set returnedModule [create $moduleType $moduleName]
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex];#sets the desired connectionPort name, default is 0
		 	if {[$moduleName $theConnectionPort validSource $sourceName] == 1} {
		 		if {[$moduleName $theConnectionPort source] ne $sourceName} {$moduleName $theConnectionPort connect $sourceName};
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
		 } else {
		 	
		 	set returnedModule $moduleName
		 	set theConnectionPort [lindex [$moduleName connectionPorts] $conPortIndex]
		 	if {[$moduleName $theConnectionPort validSource $sourceName] == 1} {
		 		if {[$moduleName $theConnectionPort source] ne $sourceName} {$moduleName $theConnectionPort connect $sourceName};
		 	} else { $this say "$sourceName is no valid source for $moduleName" }
		 	
	}
	
	return $returnedModule
	
}

#switches the given module port remotely from $this ($this must have a corresponding (i.e. same) port!)
#it works like the amira built in port connect "<modulename 1> <P0 name> connect < modulename 2> [<P1 name>]" exept that it works (e.g. there are some bugs with menu entry numberation in amira modules)
$this proc setCorrespondingPort {module port {portIndex 0}} {

	upvar #0 $module myModule
	
	if {[info exists myModule] == 0} {
		$this say "hm\.\.\. this module does not exist, maybe you deleted it - restart $moduleName"
	}
	
	$this fire;#infinit loop in Amira when here no update of all downstream modules - crashes most of the time Amira
	
	switch -exact [$this $port getTypeId] {
		HxPortMultiMenu {$myModule $port setValueString $portIndex [$this $port getLabel [$this $port getValue $portIndex]]}
		HxPortToggleList {$myModule $port setValue  $portIndex [$this $port getValue $portIndex]}
		default {$this say "could not find a corresponding port"}
	}
	
	$myModule compute

}

$this proc getToggleValuesAndCreateSurfaces {module1 module1Port module2 module2Port {portIndex 0}} {

	global extractSurface1Modul surfaceView1Modul
	global theExtractedSurfacesList theCompleteExtractedSurfacesList
	global alignPrincipalAxesModul arythmeticModul
	
	set theExtractedSurfacesList [list]
	
	for {set i 0} {$i < [$module1 $module1Port getNum]} {incr i} {
	
		if {[$module1 $module1Port getValue $i] == 1} {
			
			set theLabelOfModule1Port [$module1 $module1Port getLabel $i]
			
			$module2 $module2Port setValueString $portIndex $theLabelOfModule1Port
			$module2 fire;#essential: all downStreamConnections must be updated!
			$module2 buffer setValue 0;#add to buffer (hit add button)
			$module2 compute
			
			#here happens the extraction of the surfaces:
			$this createModuleAndConnectIfOkToSource HxViewBaseExtract $extractSurface1Modul $surfaceView1Modul
			$extractSurface1Modul action setValue 0
			$extractSurface1Modul fire
			
			set newExtractedSurface [[lindex [$extractSurface1Modul downStreamConnections] 0 0] setLabel "$theLabelOfModule1Port.surf"]
			
			lappend theExtractedSurfacesList $newExtractedSurface
				
			$newExtractedSurface master disconnect;#otherwise the newly created surface gets overriden in the next for loop iteration
			$newExtractedSurface recompute
			$newExtractedSurface cleanup
			$newExtractedSurface fixOrientation;#helps maybe
			#$newExtractedSurface makeOnePatch
			$newExtractedSurface compute
			$module2 buffer setValue 2;#remove from buffer (hit remove button)
			$module2 compute
			
		}
		
	}
	
	if {$theExtractedSurfacesList eq [list]} {#if list is empty echo warning, else process
		$this say "no labels for extraction selected"
		} else {
		
			lset theCompleteExtractedSurfacesList [concat $theCompleteExtractedSurfacesList $theExtractedSurfacesList];#save all generated surfaces in theCompleteExtractedSurfacesList list
			
			$module2 buffer setValue 1;#only get rid of the last selection in buffer which would otherwise be visible in the viewer
			$module2 compute
			
			#in this foreach iteration the surfaces in the theExtractedSurfacesList list will be further processed
			foreach theSurface $theExtractedSurfacesList {
				
				$this createModuleAndConnectIfOkToSource HxAlignPrincipalAxes $alignPrincipalAxesModul $theSurface
				$alignPrincipalAxesModul action setValue 0
				$alignPrincipalAxesModul fire
				
			}
		
		}
	
	remove $alignPrincipalAxesModul;#AlignPrincipalAxes module is not needed any more.
		
}
#
#******************** the script loops ********************
#
$this proc constructor {} {
	global allConPorts myMaterialsList myMaterialCount
	global materialSeparator LabSet labSetButtons
	
	#$this setNoSave 1

	$this sayHello
	$this select;#$this should be selected after loading
	
	$this script show
	

	#creates options for choosing which result will be produced
	$this newPortToggleList result 4
	$this result setLabel "Result"
	$this result setLabel 0 "overwrite"
	$this result setLabel 1 "polygon surface"
	$this result setLabel 2 "voxel data"
	$this result setLabel 3 "resample z"
	
	$this newPortFilename save
	$this save setLabel "Save result"
	$this save setMode 4
	
	#creates Action Button port
	$this newPortDoIt action
	$this action setLabel "Action"
	$this action setLabel 0 "Dolt"
	$this action hide;#actually need not be visible, because apply botton does the job
	
	#setting of global variables
	$this checkModuleStateAndSetVariables;
	
	#dynamically creates label ports for $this:
	for {set i 1} {$i <= [array size allConPorts]} {incr i} {
		
			$this newPortConnection labFieldPortCon$i HxUniformLabelField3
			
			#creates gui for material selection toggles:
			$this newPortSeparator materialSeparator$i
			$this newPortButtonList labSetButtons$i 2
			$this labSetButtons$i setLabel "Select label set $i"
			$this labSetButtons$i setLabel 0 "None"
			$this labSetButtons$i setLabel 1 "All"
			$this newPortToggleList labSet$i $myMaterialCount($i)
			$this labSet$i setLabel "Label set $i"
			
			#this loop sets the labels for each toggle in LabSet$i port:
			for {set x 0} {$x <= [$this labSet$i getNum]} {incr x} {
				$this say "NAME: [lindex myMaterialsList($i) $i]"
				$this labSet$i setLabel $x [lindex myMaterialsList($i) $i]
			}
			
			$this say "Materials in volume set $i: $myMaterialCount($i)"

		
		$this say "***first labelset created***\n"
	}
	

	#creates smoothing options:
	$this newPortSeparator smoothingSeparator
	$this newPortMultiMenu smoothing 3
	$this smoothing setLabel "Smoothing"
	$this smoothing setLabel 0 0 "none"
	$this smoothing setLabel 0 1 "constrained smoothing"
	$this smoothing setLabel 0 2 "unconstrained smoothing"
	
	$this newPortFloatSlider  SmoothingSliderPort1
	$this SmoothingSliderPort1 setLabel "SmoothingKernelSize"
	$this SmoothingSliderPort1 setMinMax 1 9
	$this SmoothingSliderPort1 setFormat "%.2g"
	$this SmoothingSliderPort1 setNumColumns 3
	$this SmoothingSliderPort1 setValue 4;#initial value for smoothing slider. My tests have shown this is most of the time a good value
	$this SmoothingSliderPort1 setTracking 1
	
	#recreates the options port from SurfaceGen
	$this newPortToggleList options 2
	$this options setLabel "Options"
	$this options setLabel 0 "add border"
	$this options setLabel 1 "compactify"
	
	#recreates the options port from Arithmetic
	$this newPortSeparator voxelSeparator
	$this newPortToggleList voxelOptions 2
	$this voxelOptions setLabel "Extraction options"
	
	#creates resample z options
	$this newPortSeparator resampleSeparator
	$this newPortToggleList resampleOptions 2
	$this resampleOptions setLabel "Resample options"
	
	
	if {$allConPorts(1) eq ""} {
			$this say "connect a label field to one of the label field ports"
	}
	

	#$this data hide;#shit, can not be deleted hmm...
	$this checkModuleStateAndSetVariables;
}
  
   
$this proc destructor {} {
	
	global allConPorts myMaterialsList myMaterialCount
	global materialSeparator LabSet labSetButtons
	global surfaceGen1Modul surfaceGen2Modul arythmeticModul
	global surfaceView1Modul surfaceView2Modul extractSurface1Modul extractSurface2Modul

	#removes the modules which the script eventually created when $this gets deleted:
	if {[lsearch [all] $surfaceGen1Modul] != -1} { remove $surfaceGen1Modul }
	if {[lsearch [all] $surfaceGen2Modul] != -1} { remove $surfaceGen2Modul }
	if {[lsearch [all] $surfaceView1Modul] != -1} { remove $surfaceView1Modul }
	if {[lsearch [all] $surfaceView2Modul] != -1} { remove $surfaceView2Modul }
	if {[lsearch [all] $extractSurface1Modul] != -1} { remove $extractSurface1Modul }
	if {[lsearch [all] $extractSurface2Modul] != -1} { remove $extractSurface2Modul }
	if {[lsearch [all] $arythmeticModul] != -1} { remove $arythmeticModul }
	
	#unsetting of the arrays:
	unset myMaterialsList
	unset myMaterialCount
	unset allConPorts
	unset LabSet
	unset labSetButtons
	unset materialSeparator
	
	set hideNewModules 0
	
}

$this proc compute {} {

	$this testBreak;#for safety...
	
	global moduleName surfaceGen1Modul surfaceGen2Modul
	global surfaceView1Modul surfaceView2Modul
	global extractSurface1Modul extractSurface2Modul
	global theExtractedSurfacesList theCompleteExtractedSurfacesList theArithmeticExtractedSurfacesList theResampleZExtractedSurfacesList
	global alignPrincipalAxesModul arythmeticModul
	global userLabelListSelection1 userLabelListSelection2

	global allConPorts myMaterialsList myMaterialCount
	global materialSeparator LabSet labSetButtons

	#some status checks:
	
	set myOverwriteToggleIsChecked [$this result getValue 0]
	set myPolygonSurfaceToggleIsChecked [$this result getValue 1]
	set myVoxelDataToggleIsChecked [$this result getValue 2]
	set myResampleZToggleIsChecked [$this result getValue 3]
	set resultSelectionState [$this result getState]
	
	$this checkModuleStateAndSetVariables
		
	#the next for loop and if statement takes care of right number of connection ports:
	$this say "all connection Portsss: [array size allConPorts]"
		
	
	for {set i 1} {$i <= [expr [array size allConPorts] + 0]} {incr i} {
		
		if { [$this [lindex [$this connectionPorts] $i] source] ne "" && [$this [lindex [$this connectionPorts] $i] isNew] == 1} {
			
						
			$this newPortConnection labFieldPortCon[expr $i + 1] HxUniformLabelField3
			
			#creates gui for material selection toggles:
			$this newPortSeparator materialSeparator$i
			$this newPortButtonList labSetButtons$i 2
			$this labSetButtons$i setLabel "Select label set $i"
			$this labSetButtons$i setLabel 0 "None"
			$this labSetButtons$i setLabel 1 "All"
			$this newPortToggleList labSet$i $myMaterialCount($i)
			$this labSet$i setLabel "Label set $i"
			#this loop sets the labels for each toggle in LabSet($newPortNumber) port:
			for {set x 0} {$x <= [$this labSet$i getNum]} {incr x} {
				$this say "NAME: [lindex myMaterialsList($i) $i]"
				$this labSet$i setLabel $x [lindex myMaterialsList($i) $i]
			}
						
		}
		if { [$this [lindex [$this connectionPorts] $i] source] eq "" && [lindex [$this connectionPorts] $i] ne "labFieldPortCon1"} {
			
			$this say "\n********************* ports will be deleted labFieldPortCon$i*********************\n"
			
			$this deletePort labFieldPortCon$i
			
			unset allConPorts([expr [lsearch [array get allConPorts] $i] + 1])
						
		}
		if { [$this [lindex [$this connectionPorts] $i] source] eq "" && [lindex [$this connectionPorts] $i] ne "labFieldPortCon1"} {
			
			$this say "\n********************* ports will be deleted labFieldPortCon$i*********************\n"
			
			$this deletePort materialSeparator$i
			$this deletePort labSetButtons$i
			$this deletePort labSet$i
			
			
			#unsetting of the arrays:
			unset myMaterialsList([expr [lsearch [array get myMaterialsList] $i] + 1])
			unset myMaterialCount([expr [lsearch [array get myMaterialCount] $i] + 1])
			unset LabSet([expr [lsearch [array get LabSet] $i] + 1])
			unset labSetButtons([expr [lsearch [array get labSetButtons] $i] + 1])
			unset materialSeparator([expr [lsearch [array get materialSeparator] $i] + 1])
		
		}
		
		$this checkModuleStateAndSetVariables
		
		if {[$this [lindex [$this connectionPorts] $i] source] ne ""} {
			
			#if connections are new, construct the new gui (toggles with corresponding labels)
			if {[$this $allConPorts($i) isNew] == 1} {
			
				$this say "hey i\´m connected: labFieldPortCon$i"
							
				$this $LabSet($i) setNum $myMaterialCount($i)
				#this loop sets the labels for each toggle in LabSet1 port:
				for {set x 0} {$x <= [$this $LabSet($i) getNum]} {incr x} {
					$this $LabSet($i) setLabel $i [lindex myMaterialsList($i) $i]
				}		
				
			}
			if {[$this [lindex [$this connectionPorts] $i] source] ne ""} {#if $this labFieldPortCon$i is connected to label field
				$this $materialSeparator($i) show
				$this $LabSet($i) show
				$this $labSetButtons($i) show
			} else {
				$this $materialSeparator($i) hide
				$this $LabSet($i) hide
				$this $labSetButtons($i) hide
			}
		
			#checks the bottons states from "None" and "All":
			set myButtonNoneWasHit($i) [$this $labSetButtons($i) wasHit 0]
			set myButtonAllWasHit($i) [$this $labSetButtons($i) wasHit 1]
			#check if buttons are pressed and set toggles
			if {$myButtonNoneWasHit($i) == 1 && $allConPorts($i) ne ""} {
				for {set x 0} {$x <= [$this LabSet($i) getNum]} {incr x} {
					$this LabSet($i) setValue $x 0
				}
			}
			if {$myButtonAllWasHit($i) == 1 && $allConPorts($i) ne ""} {
				for {set x 0} {$x <= [$this LabSet($i) getNum]} {incr x} {
					$this LabSet($i) setValue $x 1
				}
			}
			set labelSelectionState($i) [$this $LabSet($i) getState];#state of te selected labels
			
		}
		

	}

	
	
	
	
	

		
	#the following if/elsif statements construct most of the gui when user checks the toggles or connects modules
	if {$myPolygonSurfaceToggleIsChecked == 1} {#"polygon surface" is checked
			
		$this smoothingSeparator show
		$this smoothing show
		$this SmoothingSliderPort1 show
		$this options show
				
				
	} else {#"polygon surface" is not checked
	
		$this smoothingSeparator hide
		$this smoothing hide
		$this SmoothingSliderPort1 hide
		$this options hide
		
	}
	if {$myVoxelDataToggleIsChecked == 1} {#"voxel data" is checked
			
		$this voxelSeparator show
		$this voxelOptions show
				
				
	} else {#"voxel data" is not checked
		#TODO: here comes code when "voxel data" is not checked
		$this voxelSeparator hide
		$this voxelOptions hide
		
	}
	if {$myResampleZToggleIsChecked == 1} {#"resample z" is checked
			
		$this resampleSeparator show
		$this resampleOptions show
				
	} else {#"resample z" is not checked
		#TODO: here comes code when "resample z" is not checked
		
		$this resampleSeparator hide
		$this resampleOptions hide
		
	}
	
	
	#********** actions **********
	
	if {[$this action getValue] == 0 && $allConPorts1 ne ""} {#start calculation when action button is pressed and $this has a valid source
	
		workArea startWorking
	
		$this setVar runCounter [expr [$this getVar runCounter] + 1];#sets the new runCounter + 1
		$this say "run [$this getVar runCounter]"
		workArea setProgressInfo "starting calculation"
		workArea setProgressValue 0.4
		
		#check which label the user hast selected and save in userLabelListSelection1 list (this list containes the label and the material bundle index)
		lset userLabelListSelection1 [list]
		for {set i 0} {$i < [$this LabSet1 getNum]} {incr i} {
		
			if {[$this LabSet1 getValue $i] == 1} { lappend userLabelListSelection1 "[$this LabSet1 getLabel $i] $i" }
			
		}
		
		if {$myOverwriteToggleIsChecked == 1 && $theCompleteExtractedSurfacesList ne [list]} {#if toggle is set and list is not empty
		
			foreach i $theCompleteExtractedSurfacesList {
				remove $i
			}
			lset theCompleteExtractedSurfacesList [list];#delete all list elements
			$this say "old results overwritten"
			
		}
		
		if {$myPolygonSurfaceToggleIsChecked == 1} {
		
			$this createModuleAndConnectIfOkToSource HxGMC $surfaceGen1Modul $allConPorts1;
					
			$surfaceGen1Modul fire
		
			$surfaceGen1Modul setVar SmoothKernelSize [$this SmoothingSliderPort1 getValue];#SmoothKernelSize is a internal variable which i will allow to set by user in gui
			
			#sets corresponding gui from $this for the SurfaceGen module:
			$this setCorrespondingPort surfaceGen1Modul options 0;
			$this setCorrespondingPort surfaceGen1Modul options 1;
			$this setCorrespondingPort surfaceGen1Modul smoothing;
							
			$surfaceGen1Modul action setValue 0;#calculate the polygon surface
			
			$surfaceGen1Modul fire
			
			$this createModuleAndConnectIfOkToSource HxDisplaySurface $surfaceView1Modul [lindex [$surfaceGen1Modul downStreamConnections] 0 0];#connect a SurfaceView module for selecting the user specified labels in buffer
		
			$surfaceView1Modul compute
			$surfaceView1Modul buffer setValue 2;#make shure buffer is empty (hits botton "clear"), before filling it again with getToggleValuesAndCreateSurfaces procedure
			$surfaceView1Modul compute
			
			$this getToggleValuesAndCreateSurfaces $this LabSet1 $surfaceView1Modul materials 1;#runs main code
			
		}
		
		if {$myVoxelDataToggleIsChecked == 1} {
		
			lset theArithmeticExtractedSurfacesList [list]
			
			$this createModuleAndConnectIfOkToSource HxArithmetic $arythmeticModul [$allConPorts1 ImageData source];#connect a Arithmetic module to the voxelfield which connects to the labelfield
			$arythmeticModul inputB connect $allConPorts1
			
			
			for {set i 0} {$i < [llength $userLabelListSelection1]} {incr i} {
			
				$this testBreak;#maybe calculation here will take long
				
				$arythmeticModul expr setValue "\(A*\(B==[lindex $userLabelListSelection1 $i 1]\)\)";#sets the extraction expression
				$arythmeticModul doIt setValue 0;
				$arythmeticModul fire

				set theResultFromArithmeticCalcName [[lindex [$arythmeticModul downStreamConnections] 0 0] setLabel "[lindex $userLabelListSelection1 $i 0]"];#sets label for newly created voxelfield
				$theResultFromArithmeticCalcName master disconnect;#sisconnect, otherwise the result from arithmetic module will be overridden
				
				#append extracted voxel field to global lists:
				lappend theCompleteExtractedSurfacesList $theResultFromArithmeticCalcName;
				lappend theArithmeticExtractedSurfacesList $theResultFromArithmeticCalcName;
			}
						
		}
		
		if {$myResampleZToggleIsChecked == 1} {
			
		}
		
		workArea setProgressValue 1
		workArea stopWorking
					
	}


	#second port:

	
	
	#completion of compute procedure:
#	if {$allConPorts($i) eq "" && $allConPorts2 eq "" && [$this getVar runCounter] > 0} {
#			$this say "nothing to process - no label field connected"
#		}
#	if {[lrange $resultSelectionState 3 5] eq [list 0 0 0] && [$this getVar runCounter] > 0} {
#			$this say "nothing to process - choose on ore more result options"
#		}
		
	
}
  
  